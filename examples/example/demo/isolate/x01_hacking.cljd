(ns example.demo.isolate.x01-hacking
  "Flutter/MX port of example 2 of https://plugfox.dev/mastering-isolates/"
  (:require
    ["package:flutter/material.dart" :as m]
    ["package:flutter/painting.dart" :as p]
    ["package:flutter/widgets.dart" :as w]
    [clojure.string :as str]
    [tilton.mx.api :as mx
     :refer [dp dpx cI cF cF+ cF+n cFn cFonce mget mget? mset! mswap! minfo fasc fasc-inclusive
             fmu muv fm* mav mx-bound? wmx-iso with-cc]]
    [tilton.fmx.api :as fx
     :refer [scaffold app-bar text center column hero material-app
             container row expanded icon padding opacity ignore-pointer
             checkbox-list-tile icon-button fx-render as-dart-callback]]
    ["dart:async" :as async
     :refer [Completer StreamSubscription]]
    ["dart:isolate" :as di
     :refer [Isolate SendPort ReceivePort]]))

(defn make-app []
  (fx/material-app
    {:title "Mastering Isolates #2"}
    {; this second map is for custom state
     ; these first parameters are plain CLJD values we will need different places
     :result-port     (ReceivePort)
     ; new for CLJD MX, a formula cell can be specified as async?
     ; MX internally pretends the value starts as nil, executes a .then on the true value, a future,
     ; and in the .then handler reactively mutates the iso property to take on the deferred result.
     ; Here, though, the watch function handles everything. We could break it out into a separate cell
     ; which would begin: (cF (when-let [iso (mget me :worker-iso)}...
     :worker-iso      (cF+ [:async? true
                            :watch (fn [_ me worker _ _]
                                     (when worker
                                       (dp :got-worker-isolate! worker)))]
                        (Isolate.spawn
                          ; (we could also use here the entry-point defn above)
                          ; This is our worker. The worker:
                          ; 1. makes a ReceivePort (wRP) on which to receive tasks;
                          ; 2. sends its wRP back to the main iso on its mRP so main can send us tasks;
                          ; 3. starts listening on wRP for tasks; and
                          ; 4. when it gets an N, iterates from 1 to N inclusive sending their factorials to main
                          (fn factorial-worker [{:keys [msg-type result-port]}]
                            ; ReceivePorts cannot be sent, so main cannot provide that, so
                            ; worker makes one and immediately sends back on the result-port, a misnomer
                            (let [task-port (ReceivePort)]
                              (dp :worker-sends-its-receiver (.-sendPort task-port))
                              (.send result-port {:msg-type  :config
                                                  :task-port (.-sendPort task-port)})
                              (.listen task-port
                                (fn [{:keys [msg-type of-integer] :as task}]
                                  (case msg-type
                                    :compute-factorial (let [r (atom 1)]
                                                         (doseq [i (range 1 (inc of-integer))]
                                                           (swap! r * i)
                                                           (dp :worker-sending-result :task i :factorial= @r)
                                                           (.send result-port {:msg-type   :factorial
                                                                               :of-integer i
                                                                               :value      @r}))
                                                         (.send result-port {:msg-type :eoj}))
                                    (dp :WORKER-UNEXPECTED-TASK!!!!!!! task))))))
                          ; next is a positional arg that will be supplied to the provided entry-point.
                          ; main iso offers the sendPort of its results ReceivePort as param-0
                          {:msg-type    :config
                           :result-port (.-sendPort ^ReceivePort (mget me :result-port))}
                          .errorsAreFatal true
                          .debugName "MyIsolate"))
     :result-listener (cF+ []
                        (when (mget me :worker-iso)
                          (dp :main-starts-listening)
                          (.listen ^ReceivePort (mget me :result-port)
                            (fn [message]
                              ; Hmmm. Instead of insisting that the first message back from the
                              ; isolate be the .-sendPort of its ReceivePort, we assume the isolate does that
                              ; first, as it should.
                              (dp :main-hears message)
                              (case (:msg-type message)
                                :config (do (dp :result-config!! message)
                                          (wmx-iso
                                            (dp :main-msets-task-out-port message)
                                            (mset! me :task-out-port (:task-port message))))
                                :factorial (dp :factorial-of (:of-integer message) :is (:value message))
                                :eoj (do (dp :eoj!!!!)
                                       (.close ^ReceivePort (mget me :result-port))
                                       (.kill ^Isolate (mget me :worker-iso))))))))
     :task-out-port   (cI nil :watch (fn [_ me new _ _]
                                       (dp :task-out-port-now new)))
     :dispatcher      (cF (when-let [task2w (mget me :task-out-port)]
                            ; now we have a pipe to the worker, and can send it our one task: 7
                            (dp :dispatcher-sending-7-to-task-out task2w)
                            (.send ^SendPort task2w
                              {:msg-type   :compute-factorial
                               :of-integer 7})))            ; <======== BINGO! task dispatch
     }
    (fx/scaffold
      {:appBar (fx/app-bar {:title (fx/text "Simple BidirectionalLink")})})))
