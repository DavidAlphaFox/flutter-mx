(ns example.demo.isolate.ixp.ixp
  (:require
    ["package:flutter/material.dart" :as m]
    ["package:flutter/painting.dart" :as p]
    ["package:flutter/widgets.dart" :as w]
    ["dart:io" :as io]
    ["dart:convert" :as convert]
    [clojure.string :as str]
    [clojure.walk :as walk]
    [tilton.mx.util :as util]
    [tilton.mx.api :as mx
     :refer [dp dpx cI cF cF+ cF+n cFn cFonce mget mget? mset! mswap! minfo fasc fasc-inclusive
             fmu muv muiv fm* mav mx-bound? wmx-iso]]
    [tilton.fmx.api :as fx
     :refer [scaffold app-bar text center column hero material-app
             container row expanded icon padding opacity ignore-pointer
             checkbox-list-tile icon-button fx-render dart-cb]]
    [example.demo.isolate.common :as cmn
     :refer [clock-face slow-is-prime? just-slow-is-prime? dbgiso dbgisox say-delay result-clear]]
    [example.demo.isolate.ixp.iso-control
     :refer [on-off pause-resume kill ping run-enabled?
             run-prime? decide-prime? decide-prime-in-main]]
    ["dart:isolate" :as di
     :refer [Isolate SendPort Capability ReceivePort]]))

(defn slo-prime-worker-listener [to-main {:keys [msg-type n] :as task}]
  (cond
    (string? task)
    (slo-prime-worker-listener to-main (util/dart-map->cljd-map
                                         (convert/jsonDecode task)))
    :else (do (dp :slo-prime-w-sees task)
              (case msg-type
                :decide-prime?
                (.send ^SendPort to-main
                  {:msg-type :prime-decision
                   :n        n
                   :value    (cmn/just-slow-is-prime? n)})
                "ping"
                (.send ^SendPort to-main
                  {:msg-type :ping-ack
                   :response (:response task)})

                (dp :worker-IGNORES-task task))))
  nil)

(defn slo-prime-worker [{:keys [msg-type ^SendPort to-main] :as start}]
  (let [from-main (ReceivePort)]
    (dp :worker-sends-its-receiver (.-sendPort from-main))
    (.send to-main {:msg-type :config
                    :to-iso   (.-sendPort from-main)})
    (dp :worker-starts-listening from-main)
    (.listen from-main (fn [msg]
                         (slo-prime-worker-listener to-main msg)))
    nil))

;;; --- make app ----------------------------------------

(defn make-app []
  (fx/material-app {}
    {:name          :app
     :start-paused? false
     :iso           (cF+ [:async? true
                          :watch (fn [_ me new-iso prior _]
                                   (when (dart/is? prior Isolate)
                                     (dbgisox :watch-killing-prior-iso! prior)
                                     (.kill ^Isolate prior))
                                   (when new-iso
                                     (wmx-iso
                                       (let [cap (.-pauseCapability ^Isolate new-iso)]
                                         (dpx :new-iso-res-cap!!!!!!!!!!! (.-hashCode cap))
                                         (mset! me :resume-cap cap))))
                                   (dbgiso :watch-sees-new-iso! new-iso))]
                      (when (mget (fm* :on-off) :value)
                        (Isolate.spawn slo-prime-worker {:msg-type :config
                                                         :to-main  (.-sendPort ^ReceivePort (mget me :from-iso))}
                          .paused (mget me :start-paused?)
                          .onExit (.-sendPort ^ReceivePort (mget me :on-exit))
                          .onError (.-sendPort ^ReceivePort (mget me :on-error)))))
     :resume-cap    (cI nil :watch (fn [_ _ new prior _]
                                     (dpx :resume-cap! new :prior prior)))

     :iso-paused?   (cF+n [:watch (fn [_ me paused? prior _]
                                    (when-let [iso ^Isolate? (mget me :iso)]
                                      (when (mx-bound? prior)
                                        (cond
                                          paused? (let [resumer (.pause iso)
                                                        res2 (.-pauseCapability ^Isolate iso)]
                                                    (dp :PAUSE :res= (= resumer res2)
                                                      :rcap (.-hashCode resumer) resumer
                                                      :direct (.-hashCode res2) res2)
                                                    (wmx-iso
                                                      (mset! me :resume-cap resumer)))
                                          :else (let [resumer (mget me :resume-cap)
                                                      res2 (.-pauseCapability ^Isolate iso) ;; bad idea
                                                      ;; res2 would work only on iso started paused, only once
                                                      ]
                                                  (dp :RESUME :reso (= resumer res2)
                                                    :rcap (.-hashCode resumer) resumer
                                                    :direct (.-hashCode res2) res2)
                                                  (.resume iso resumer))))))]
                      (mget me :start-paused?))
     :main-listener (cF+ []
                      (when-let [iso (mget me :iso)]
                        (when-let [from-iso (mget me :from-iso)]
                          (dp :main-listenng!!)
                          (.listen ^ReceivePort from-iso
                            (fn [{:keys [to-iso] :as result}]
                              (dp :main-hears!!! result)
                              (case (:msg-type result)
                                :config (wmx-iso
                                          (dp :main-sees-config!!!! result)
                                          (mset! me :to-iso (:to-iso result)))
                                (wmx-iso
                                  (dpx :forwarding-result result)
                                  (mset! me :worker-result result))))))))
     :worker-result (cI nil :watch (fn [_ _ new _ _]
                                     (when new (dp :worker-result new))))
     :from-iso      (cF (when (mget (fm* :on-off) :value)
                          (ReceivePort)))
     :to-iso        (cI nil)
     ; run
     :run-job       (cI nil :ephemeral? true)
     :runner        (cF+ [:async? true
                          :watch (fn [_ me new prior _]
                                   (when (not (nil? new))
                                     (mx/with-cc :runner-up
                                       (result-clear)
                                       (dp :runnerw-decides!!!!!
                                         new :is-prime? (:value new))
                                       (mset! me :worker-result
                                         {:msg-type :prime-decision
                                          :n        (:n new)
                                          :run-id   (:run-id new)
                                          :value    (:value new)}))))]
                      (when (mx/fm*val :auto-run)
                        (dp :runner-auto-run!!!)
                        (when-let [{:keys [n] :as job} (mget me :run-job)]
                          (dp :runner-job!!! job)
                          (Isolate.run (fn [] (merge job {:msg-type :prime-decision
                                                          :value    (just-slow-is-prime? n)}))))))
     ; detritus
     :on-exit       (cF+ [:watch (fn [_ me new _ _]
                                   (.listen ^ReceivePort new
                                     (fn [msg] (dp :on-exit!!!! msg))))]
                      (ReceivePort))
     :on-error      (cF+ [:watch (fn [_ me new _ _]
                                   (.listen ^ReceivePort new
                                     (fn [msg] (dp :on-error!!!! msg))))]
                      (ReceivePort))
     }
    (scaffold
      {:appBar (app-bar {:title           (fx/text "Isolate Explorer 23")
                         :backgroundColor m/Colors.pink.shade50})}
      (column                                               ;{:crossAxisAlignment m/CrossAxisAlignment.stretch}
        (clock-face)
        (row {:mainAxisAlignment m/MainAxisAlignment.spaceEvenly}
          (on-off)
          (pause-resume))
        (row {:mainAxisAlignment m/MainAxisAlignment.spaceEvenly}
          (kill)
          (ping "Pong"))
        (row {:mainAxisAlignment m/MainAxisAlignment.spaceEvenly}
          (decide-prime-in-main 9000039)
          (decide-prime-in-main 9000041))
        (row {:mainAxisAlignment m/MainAxisAlignment.spaceEvenly}
          (decide-prime? 9000039)
          (decide-prime? 9000041))
        (row {:mainAxisAlignment m/MainAxisAlignment.spaceEvenly}
          (run-prime? 9000039)
          (run-prime? 9000041))
        (run-enabled?)

        (text {:style (p/TextStyle .fontSize 20)}
          (let [{:keys [msg-type n value] :as result} (mav :worker-result)]
            (case msg-type
              :prime-decision (str "N " (or n "bug:unknown") " is " (when-not value "NOT ") "prime.")
              :ping-ack (:response result)
              "...")))))))

