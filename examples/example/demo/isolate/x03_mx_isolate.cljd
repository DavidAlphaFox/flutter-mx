(ns example.demo.isolate.x03-mx-isolate
  (:require
    ["package:flutter/gestures.dart" :as g]
    ["package:flutter/material.dart" :as m
     :refer [Canvas Size]]
    ["package:vector_math/vector_math_64.dart" :as vm]
    ["dart:math" :as math
     :refer [pi cos sin]]
    ["dart:async" :as async
     :refer [Completer StreamSubscription]]
    ["dart:isolate" :as di
     :refer [Isolate SendPort ReceivePort]]

    [tilton.mx.api :as md]
    [tilton.mx.cell.base :as cb]
    [tilton.mx.api :as mx
     :refer [dp dpx cI cF cF+ cF+n cFn cFonce mget mget? mset! mswap! minfo fasc fasc-inclusive
             fmu muv fm* mav mx-bound? wmx-iso with-cc]]
    [tilton.fmx.api :as fx]
    [example.demo.isolate.common :as cmn
     :refer [clock-face slow-is-prime? use-compute?]]))

(defn make-iso [worker-fn result-handler]
  (md/make                                                  ;; :mx-type ::mx-isolate
    :result-port (ReceivePort)
    :worker-iso (cF+ [:async? true
                      :watch (fn [_ me worker _ _]
                               (when worker
                                 (dp :got-worker-isolate! worker)))]
                  (Isolate.spawn
                    (fn [msg]
                      (dp :stock-worker-sees msg)
                      (let [{:keys [msg-type ^SendPort result-port]} msg
                            task-port (ReceivePort)]
                        (dp :stock-worker-sends-its-receiver (.-sendPort task-port))
                        (.send result-port {:msg-type  :config
                                            :task-port (.-sendPort task-port)})
                        (dp :stock-worker-starts-listening task-port)
                        (.listen task-port (fn [task]
                                             (dp :stock-worker-sees-task task)
                                             (let [result (worker-fn task)]
                                               (dp :worker-fn-returns-result result)
                                               (.send result-port {:msg-type :result
                                                                   :value    result}))
                                             nil))
                        nil))
                    {:msg-type    :config
                     :result-port (.-sendPort ^ReceivePort (mget me :result-port))}
                    .errorsAreFatal true
                    .debugName "make-iso-isolate"))
    :result-listener (cF+ []
                       (when (mget me :worker-iso)
                         (dp :main-starts-listening (mget me :result-port))
                         (.listen ^ReceivePort (mget me :result-port)
                           (fn [res]
                             (dp :main-hears res)
                             (case (:msg-type res)
                               :config (do (dp :main-gets-res-config!! res)
                                         (wmx-iso
                                           (dp :main-msets-task-out-port res)
                                           (mset! me :task-out-port (:task-port res))))
                               (do
                                 (dp :yes-handling res)
                                 (result-handler res)))))))
    :task-out-port (cI nil :watch (fn [_ me new-val _ _]
                                    (dp :task-out-port-now new-val)))))

(defn try-this [the-app]
  (make-iso
    ;; worker
    (fn [{:keys [iso msg-type of-integer] :as task}]
      (dp :worker-entry msg-type)
      ;(dp :worker-entry-app (nil? the-app)) ;; <=== NOT OK HERE!!!!!!!!!!!!!!
      (case msg-type
        :compute-factorial (let [r (atom 1)]
                             (doseq [i (range 1 (inc of-integer))] (swap! r * i))
                             {:of-integer of-integer
                              :value      @r})
        (dp :WORKER-UNEXPECTED-TASK!!!!!!!)))
    ;; result handler
    (fn [result]
      (dp :result-handler-entry result)
      (case (:msg-type result)
        :config (throw "result-handler got config")
        :result (let [v (:value result)]
                  (dp :factorial-of (:of-integer v) :is (:value v))
                  (dp :works  (keys result))
                  ;; unable to even reference a lexical in next line..
                  ; (dp :fails  (nil? the-app)) ;; <=== FIX-ISH comment this out
                  #_ (dp :fails-on-invalid-send
                       (:name (deref the-app)))
                  #_(wmx-iso
                      (mset! (fmu :facto-display)
                        :factorial (:value result)))
                  #_#_(.close ^ReceivePort (mget me :result-port))
                          (.kill ^Isolate (mget me :worker-iso))))
      nil)))

(defn make-app []
  (let [title "MX Iso Clock"]
    (fx/material-app
      {:title title}
      {:name     :app
       :fact-iso (cF (let [the-app me]
                       (dp :the-app (minfo the-app)) ;; OK HERE!!!!!!!!!!!!!!!!
                       (try-this the-app)
                       ))}
      (fx/scaffold
        {:appBar (fx/app-bar {:title (fx/text title)})
         :floatingActionButton
         (fx/floating-action-button
           {:onPressed (fx/as-dart-callback []
                         (dp :PRESSED-sees (minfo (fmu :facto-display)))
                         (wmx-iso
                           (let [fo (fmu :facto-display)]
                             (dp :bumping-of!!!! (minfo fo))
                             (mswap! fo :of + 2))))
            :tooltip   "Send msg"})}
        (fx/column
          {:mainAxisAlignment m/MainAxisAlignment.spaceEvenly}
          ;;(clock-face)

          (fx/text {}
            {:name      :facto-display
             :of        (cI 1 :watch (fn [_ me new-val _ _]
                                       (dp :of-is-now new-val)
                                       (when-let [iso (mav :fact-iso)]
                                         (dp :iso-ok iso)
                                         (when-let [task2w (mget iso :task-out-port)]
                                           (dp :got-task-o task2w)
                                           ; now we have a pipe to the worker, and can send it our one task: 7
                                           (dp :dispatcher-sending-to-task-out new-val)
                                           (.send ^SendPort task2w
                                             {:msg-type   :compute-factorial
                                              :of-integer new-val})))))
             :factorial (cI :RSN :watch (fn [_ me new-val _ _]
                                          (dp :facto!!!!!!!!!!!!! new-val)))}
            (str "The factorial of " (mget me :of) " is " (mget me :factorial))))))))




