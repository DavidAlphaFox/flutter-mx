(ns example.demo.isolate.x03-mx-isolate
  (:require
    ["package:flutter/gestures.dart" :as g]
    ["package:flutter/material.dart" :as m
     :refer [Canvas Size]]
    ["package:vector_math/vector_math_64.dart" :as vm]
    ["dart:math" :as math
     :refer [pi cos sin]]
    ["dart:async" :as async
     :refer [Completer StreamSubscription]]
    ["dart:isolate" :as di
     :refer [Isolate SendPort ReceivePort]]

    [tilton.mx.api :as md]
    [tilton.mx.cell.base :as cb]
    [tilton.mx.api :as mx
     :refer [dp dpx cI cF cF+ cF+n cFn cFonce mget mget? mset! mswap! minfo fasc fasc-inclusive
             fmu muv fm* mav mx-bound? wmx-iso with-cc]]
    [tilton.fmx.api :as fx]
    [example.demo.isolate.common :as cmn
     :refer [clock-face slow-is-prime? use-compute?]]))

(defn make-iso [worker-fn result-handler]
  (dpx :making-iso!!!!!!-worker worker-fn)
  (md/make                                                  ;; :mx-type ::mx-isolate
    :result-port (ReceivePort)
    :worker-iso (cF+ [:async? true
                      :watch (fn [_ me worker _ _]
                               (when worker
                                 (dpx :got-worker-isolate! worker)))]
                  (dpx :the-formula-runs!!!!!!!!!!!!!!!!!!!!!!!!!!!)
                  (dpx :the-formula-sees-lex!!!! worker-fn)
                  (let [result-port (mget me :result-port)]
                    (dpx :spawn-rport!!!!!!!!! result-port)
                    (dpx :spawn-sendport!!!!!!!!! (.-sendPort ^ReceivePort result-port))
                    (Isolate.spawn
                      (fn [msg]
                        (dpx :stock-worker-sees (keys msg))
                        (let [{:keys [msg-type ^SendPort result-port msg-worker]} msg
                              task-port (ReceivePort)]
                          (dpx :stock-worker-sends-its-receiver-rsn)
                          (dpx :stock-worker-sees-msg-worker msg-worker)
                          (dpx :stock-worker-sends-its-receiver (.-sendPort task-port))
                          (.send result-port {:msg-type  :config
                                              :task-port (.-sendPort task-port)})
                          (dpx :stock-worker-starts-listening task-port)
                          (.listen task-port (fn [task]
                                               (dpx :stock-worker-sees-task task msg-worker)
                                               ; (dp :stock-worker-sees-worker-fn worker-fn)

                                               (let [result (msg-worker task)]
                                                 (dpx :worker-fn-returns-result result)
                                                 (.send result-port {:msg-type :result
                                                                     :value    result}))
                                               nil))
                          nil))
                      {:msg-type    :config
                       :msg-worker  worker-fn               ;; (fn [] nil) ;; worker-fn
                       :result-port (.-sendPort ^ReceivePort (mget me :result-port))}
                      .errorsAreFatal true
                      .debugName "make-iso-isolate")))
    :result-listener (cF+ []
                       (dpx :result-listener-cf-runs)
                       (when (mget me :worker-iso)
                         (dpx :main-starts-listening (mget me :result-port))
                         (.listen ^ReceivePort (mget me :result-port)
                           (fn [res]
                             (dpx :main-hears res)
                             (case (:msg-type res)
                               :config (do (dpx :main-gets-res-config!! res)
                                         (wmx-iso
                                           (dpx :main-msets-task-out-port res)
                                           (mset! me :task-out-port (:task-port res))))
                               (do
                                 (dpx :yes-handling res)
                                 (result-handler res)))))))
    :task-out-port (cI nil :watch (fn [_ me new-val _ _]
                                    (dpx :task-out-port-now new-val)))))


(defn make-app []
  (let [title "MX Iso Clock"]
    (fx/material-app
      {:title title}
      {:name     :app
       :fact-iso (cF (let [the-app me]
                       ;(dp :the-app (minfo the-app)) ;; OK HERE!!!!!!!!!!!!!!!!
                       #_ (try-this the-app)
                       (make-iso
                         ;; worker
                         (fn [{:keys [msg-type of-integer] :as task}]
                           (case msg-type
                             :compute-factorial (let [r (atom 1)]
                                                  (doseq [i (range 1 (inc of-integer))] (swap! r * i))
                                                  {:of-integer of-integer
                                                   :factorial  @r})
                             (dp :WORKER-UNEXPECTED-TASK!!!!!!!)))
                         ;; result handler
                         (fn [result]
                           (case (:msg-type result)
                             :config (throw "result-handler got config")
                             :result (let [{:keys [of-integer factorial]} (:value result)]
                                       (dp :result result :factorial-of of-integer :is factorial)
                                       (wmx-iso
                                         (mset! (fm* :facto-display the-app)
                                           :factorial factorial))
                                       #_#_(.close ^ReceivePort (mget me :result-port))
                                               (.kill ^Isolate (mget me :worker-iso))))
                           nil))))}
      (fx/scaffold
        {:appBar (fx/app-bar {:title (fx/text title)})
         :floatingActionButton
         (fx/floating-action-button
           {:onPressed (fx/as-dart-callback []
                         (dpx :PRESSED-sees (minfo (fmu :facto-display)))
                         (wmx-iso
                           (let [fo (fmu :facto-display)]
                             (dp :bumping-of!!!! (minfo fo))
                             (mswap! fo :of + 2))))
            :tooltip   "Send msg"})}
        (fx/column
          {:mainAxisAlignment m/MainAxisAlignment.spaceEvenly}
          (clock-face)

          (fx/text {}
            {:name      :facto-display
             :of        (cI 1 :watch (fn [_ me new-val _ _]
                                       (dpx :of-is-now new-val)
                                       (when-let [iso (mav :fact-iso)]
                                         (dpx :iso-ok iso)
                                         (when-let [task2w (mget iso :task-out-port)]
                                           (dpx :got-task-o task2w)
                                           ; now we have a pipe to the worker, and can send it our one task: 7
                                           (dpx :dispatcher-sending-to-task-out new-val)
                                           (.send ^SendPort task2w
                                             {:msg-type   :compute-factorial
                                              :of-integer new-val})))))
             :factorial (cI :RSN :watch (fn [_ me new-val _ _]
                                          (dpx :facto!!!!!!!!!!!!! new-val)))}
            (str "The factorial of " (mget me :of) " is " (mget me :factorial))))))))




