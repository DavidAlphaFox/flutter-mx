(ns example.demo.isolate.x00-spawn
  (:require
    ["package:flutter/material.dart" :as m]
    ["package:flutter/painting.dart" :as p]
    ["package:flutter/widgets.dart" :as w]
    [clojure.string :as str]
    [tilton.mx.api :as mx
     :refer [dp dpx cI cF cF+ cF+n cFn cFonce mget mget? mset! mswap! minfo fasc fasc-inclusive
             fmu muv fm* mav mx-bound? wmx-iso]]
    [tilton.fmx.api :as fx
     :refer [scaffold app-bar text center column hero material-app
             container row expanded icon padding opacity ignore-pointer
             checkbox-list-tile icon-button fx-render as-dart-callback]]
    ["dart:isolate" :as di
     :refer [Isolate SendPort ReceivePort]]))

;;; we do nothing but spawn an isolate and play with debugName,
;;; kill (immediate or beforeNextEvent), and exit.
;;;

(declare say-delay dbgiso)

;;; --- the original, paraphrased ----------------------------------------------

(defn factorial-worker [n]
  (reduce (fn [a b]
            (let [f (* a b)]
              (dp :factorial-of b :is f)
              f))
    (range 1 (inc n))))

(defn make-app []
  (fx/material-app {}
    {:iso (cF+ [:async? true
                :watch (fn [_ me new-iso _ _]
                         (dp :watch-sees-new-iso new-iso)
                         (when new-iso
                           (await (Future.delayed (Duration .seconds 1)))
                           (.kill ^Isolate new-iso .priority Isolate.beforeNextEvent)
                           (dp :watch-just-killed-iso new-iso)))]
            (Isolate.spawn
              factorial-worker 5
              .errorsAreFatal true
              .debugName "MyIsolate"))}
    (fx/scaffold
      {:appBar (fx/app-bar {:title (fx/text "Intentionally Left Blank")})})))

; From Plague Fox, Example 1: https://plugfox.dev/mastering-isolates/
;
; "Here's an example of how to spawn an isolate, send a message to it, and then kill it after a delay "
;
; /// First of all, let's spawn an isolate and send a message to it.
;
;import 'dart:isolate';
;
;void main() => Future<void>(() async {
;      final isolate = await Isolate.spawn<int>(
;        entryPoint,
;        7,
;        errorsAreFatal: true, // uncaught errors will terminate the isolate
;        debugName: 'MyIsolate', // name in debuggers and logging
;      );
;      await Future<void>.delayed(const Duration(seconds: 1));
;      isolate.kill(); // Kill the isolate.
;    });
;
;/// The entry point of the our isolate.
;void entryPoint(int payload) {
;  for (var i = 1, r = 1; i <= payload; i++, r *= i) {
;    // Send a message to the main isolate.
;    print('$i! = $r');
;  }
;}


(defn dbgiso
  "A handy Iso debugger that gracefully handles dead Isos"
  ([tag] (dbgiso tag Isolate.current))
  ([tag iso] (dp :iso! tag (when iso
                             (try (.-debugName ^io/Isolate iso)
                               (catch Error e
                                 ;;(dp :caught!!!! e)
                                 "dead-iso"))))))

(defn say-delay [n tag]
  (dp :delaying n :tag tag)
  (await (Future.delayed (Duration .seconds 1))))

