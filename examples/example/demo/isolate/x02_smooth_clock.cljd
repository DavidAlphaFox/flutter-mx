(ns example.demo.isolate.x02-smooth-clock
  (:require
    ["package:flutter/gestures.dart" :as g]
    ["package:flutter/material.dart" :as m
     :refer [Canvas Size]]
    ["package:vector_math/vector_math_64.dart" :as vm]
    ["dart:math" :as math
     :refer [pi cos sin]]
    ["dart:async" :as async
     :refer [Completer StreamSubscription]]

    ["dart:isolate" :as di
     :refer [Isolate SendPort ReceivePort]]
    [cljd.flutter.alpha :as f]
    [tilton.mx.cell.base :as cb]

    [tilton.mx.base :refer [dprn dp dpx]]

    [tilton.mx.api :as mx
     :refer [dp dpx cI cF cF+ cF+n cFn cFonce mget mget? mset! mswap! minfo fasc fasc-inclusive
             fmu muv fm* mav mx-bound? wmx-iso with-cc]]

    [tilton.fmx.api :as fx]))

(declare clock-face)

(defn make-app []
  (let [title "Smooth Clock"]
    (fx/material-app
      {:title title}
      (fx/scaffold
        {:appBar (fx/app-bar {:title (fx/text title)})
         :floatingActionButton
         (fx/floating-action-button
           {:onPressed (fx/as-dart-callback []
                         (wmx-iso
                           (let [fo (fmu :facto-display)]
                             (dp :sending-task!!!! fo)
                             (mswap! fo :of + 2))))
            :tooltip   "Send msg"})}
        (fx/column
          (clock-face)
          (fx/text {}
            {:name            :iso-home
             :target          :facto-display
             :result-port     (ReceivePort)
             :worker-iso      (cF+ [:async? true
                                    :watch (fn [_ me worker _ _]
                                             (when worker
                                               (dpx :got-worker-isolate! worker)))]
                                (Isolate.spawn
                                  (fn factorial-worker [{:keys [msg-type ^SendPort result-port]}]
                                    (let [task-port (ReceivePort)]
                                      (dpx :worker-sends-its-receiver (.-sendPort task-port))
                                      (.send result-port {:msg-type  :config
                                                          :task-port (.-sendPort task-port)})
                                      (.listen task-port
                                        (fn [{:keys [msg-type of-integer] :as task}]
                                          (case msg-type
                                            :compute-factorial (let [r (atom 1)]
                                                                 (doseq [i (range 1 (inc of-integer))]
                                                                   (swap! r * i)
                                                                   (dpx :worker-sending-result :task i :factorial= @r)
                                                                   (.send result-port {:msg-type   :factorial
                                                                                       :of-integer i
                                                                                       :value      @r}))
                                                                 (.send result-port {:msg-type :eoj
                                                                                     :value    @r}))
                                            (dp :WORKER-UNEXPECTED-TASK!!!!!!! task))))))
                                  {:msg-type    :config
                                   :result-port (.-sendPort ^ReceivePort (mget me :result-port))}
                                  .errorsAreFatal true
                                  .debugName "MyIsolate"))
             :result-listener (cF+ []
                                (when (mget me :worker-iso)
                                  (dpx :main-starts-listening)
                                  (.listen ^ReceivePort (mget me :result-port)
                                    (fn [message]
                                      (dpx :main-hears message)
                                      (case (:msg-type message)
                                        :config (do (dpx :result-config!! message)
                                                  (wmx-iso
                                                    (dpx :main-msets-task-out-port message)
                                                    (mset! me :task-out-port (:task-port message))))
                                        :factorial (dpx :factorial-of (:of-integer message) :is (:value message))
                                        :eoj (do (dpx :eoj!!!! message)
                                               (wmx-iso
                                                 (mset! (fmu (mget me :target))
                                                   :factorial (:value message)))
                                               #_#_(.close ^ReceivePort (mget me :result-port))
                                                       (.kill ^Isolate (mget me :worker-iso))))))))
             :task-out-port   (cI nil :watch (fn [_ me new _ _]
                                               (dpx :task-out-port-now new)))

             :dispatcher      (cF (when-let [task-out (mget me :task-out-port)]
                                    (fn disp-task [task-n]
                                      (dp :dispatcher-sending-N-to-task-out task-n)
                                      (.send ^SendPort task-out
                                        {:msg-type   :compute-factorial
                                         :of-integer task-n}))))}
            "ISO")
          (fx/text {}
            {:name      :facto-display
             :of        (cI 1 :watch (fn [_ me new _ _]
                                       (when new
                                         (dpx :display-sees-new new)
                                         (when-let [d (mget me :dispo)]
                                           (dpx :display-sees-dispo d :sending new)
                                           (d new)))))
             :dispo     (cF+ [:watch (fn [_ me dsp-fn _ _]
                                       (when dsp-fn
                                         (dpx :got-disp-fn dsp-fn)))]
                          (mget (fmu :iso-home) :dispatcher))
             :factorial (cI :RSN)}
            (str "The factorial of " (mget me :of) " is " (mget me :factorial))))))))


; void paint(Canvas canvas, Size size) {
;    final center = size.center;
;    final radius = size.width / 2;
;
;    // Draw the watch face background
;    canvas.drawCircle(center, radius, Paint()..color = Colors.white);
;
;    // Draw the second hand
;    final handLength = radius * 0.8;
;    final handAngle = rotationTween.value * 360;
;    final handStart = Offset(center.dx, center.dy);
;    final handEnd = Offset(
;      center.dx + handLength * cos(handAngle * pi / 180),
;      center.dy + handLength * sin(handAngle * pi / 180),
;    );
;
;    canvas.drawLine(handStart, handEnd, Paint()..color = Colors.red..strokeWidth = 5);
;  }
(defn clock-face []
  (fx/custom-paint
    {:size    (m/Size 400 400)                              ;double/infinity double/infinity)
     :painter (cF (let [tick (mget me :tick)]
                    (reify :extends (m/CustomPainter)
                      (paint [this ^Canvas canvas ^Size size]
                        ;(dp :size!!!! size)
                        (let [center (.center size (m/Offset 0 0))
                              radius (- (/ (.-width size) 2) 24)
                              pin-p (doto (m/Paint)
                                      (-> .-color (set! m/Colors.grey.shade400))
                                      (-> .-style (set! m/PaintingStyle.fill)))
                              dial-p (doto (m/Paint)
                                       (-> .-color (set! m/Colors.grey))
                                       (-> .-style (set! m/PaintingStyle.stroke)))
                              hand-p (doto (m/Paint)
                                       (-> .-color (set! m/Colors.red))
                                       (-> .-strokeWidth (set! 1.0))
                                       (-> .-style (set! m/PaintingStyle.stroke)))
                              hand-len (* radius 0.9)
                              hand-angle (/ tick 10.0)
                              hand-start center
                              hand-end (m/Offset
                                         (+ (.-dx center) (* hand-len
                                                            (cos (/ (* hand-angle pi) 180))))
                                         (+ (.-dy center) (* hand-len
                                                            (sin (/ (* hand-angle pi) 180)))))
                              ]
                          ;
                          ; (dp :center center)
                          (.drawCircle ^Canvas canvas center radius dial-p)
                          (.drawLine ^Canvas canvas hand-start hand-end hand-p)
                          (.drawCircle ^Canvas canvas center 10 pin-p)
                          ))
                      (shouldRepaint [this _] true))))}
    {:second (cI 0.6)
     :tick   (cI 0 #_#_:watch (fn [_ me tick _ _]
                                (dp :tick tick)))
     :clock  (cF+ [:on-quiesce (fn [c] (when-let [tmr ^async/Timer (cb/c-value c)]
                                         (.cancel tmr)))]
               (async/Timer.periodic (Duration .milliseconds 10)
                 (fn [^async/Timer tmr]
                   (wmx-iso
                     (mset! me :tick (.-tick tmr))))))}))

#_(defn clock-face []
    (m/CustomPaint
      .size (m/Size double/infinity double/infinity)
      .painter (reify :extends (m/CustomPainter)
                 (paint [this ^Canvas canvas ^Size size]
                   (dp :size!!!! size)
                   (let [center (.center size (m/Offset 0 -200))
                         radius (- (/ (.-width size) 4) 24)
                         pin-p (doto (m/Paint)
                                 (-> .-color (set! m/Colors.grey.shade400))
                                 (-> .-style (set! m/PaintingStyle.fill)))
                         dial-p (doto (m/Paint)
                                  (-> .-color (set! m/Colors.grey))
                                  (-> .-style (set! m/PaintingStyle.stroke)))
                         hand-p (doto (m/Paint)
                                  (-> .-color (set! m/Colors.red))
                                  (-> .-strokeWidth (set! 5.0))
                                  (-> .-style (set! m/PaintingStyle.stroke)))
                         hand-len (* radius 0.9)
                         hand-angle 42
                         hand-start center
                         hand-end (m/Offset
                                    (+ (.-dx center) (* hand-len
                                                       (math/cos (/ (* hand-angle pi) 180))))
                                    (+ (.-dy center) (* hand-len
                                                       (sin (/ (* hand-angle pi) 180)))))
                         ]
                     (dp :center center)
                     (.drawCircle ^Canvas canvas center radius dial-p)
                     (.drawLine ^Canvas canvas hand-start hand-end hand-p)
                     (.drawCircle ^Canvas canvas center 10 pin-p)
                     ))
                 (shouldRepaint [this _] true))))


; import 'package:flutter/material.dart';
;
;/// Flutter code sample for [TweenAnimationBuilder].
;
;void main() => runApp(const TweenAnimationBuilderExampleApp());
;
;class TweenAnimationBuilderExampleApp extends StatelessWidget {
;  const TweenAnimationBuilderExampleApp({super.key});
;
;  @override
;  Widget build(BuildContext context) {
;    return MaterialApp(
;      home: Scaffold(
;        appBar: AppBar(title: const Text('TweenAnimationBuilder Sample')),
;        body: const Center(
;          child: TweenAnimationBuilderExample(),
;        ),
;      ),
;    );
;  }
;}
;
;class TweenAnimationBuilderExample extends StatefulWidget {
;  const TweenAnimationBuilderExample({super.key});
;
;  @override
;  State<TweenAnimationBuilderExample> createState() =>
;      _TweenAnimationBuilderExampleState();
;}
;
;class _TweenAnimationBuilderExampleState
;    extends State<TweenAnimationBuilderExample> {
;  double targetValue = 24.0;
;
;  @override
;  Widget build(BuildContext context) {
;    return TweenAnimationBuilder<double>(
;      tween: Tween<double>(begin: 0, end: targetValue),
;      duration: const Duration(seconds: 1),
;      builder: (BuildContext context, double size, Widget? child) {
;        return IconButton(
;          iconSize: size,
;          color: Colors.blue,
;          icon: child!,
;          onPressed: () {
;            setState(() {
;              targetValue = targetValue == 24.0 ? 48.0 : 24.0;
;            });
;          },
;        );
;      },
;      child: const Icon(Icons.aspect_ratio),
;    );
;  }
;}