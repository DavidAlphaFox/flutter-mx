(ns example.demo.isolate.x02-smooth-clock
  (:require
    ["package:flutter/gestures.dart" :as g]
    ["package:flutter/material.dart" :as m
     :refer [Canvas Size]]
    ["package:vector_math/vector_math_64.dart" :as vm]
    ["dart:math" :as math
     :refer [pi cos sin]]
    ["dart:async" :as async
     :refer [Completer StreamSubscription]]
    ["dart:isolate" :as di
     :refer [Isolate SendPort ReceivePort]]

    [tilton.mx.cell.base :as cb]
    [tilton.mx.api :as mx
     :refer [dp dpx cI cF cF+ cF+n cFn cFonce mget mget? mset! mswap! minfo fasc fasc-inclusive
             fmu muv fm* mav mx-bound? wmx-iso with-cc]]
    [tilton.fmx.api :as fx]))

(declare clock-face)

(defn facto-worker [{:keys [msg-type of-integer] :as task} result-port]
  (dp :stock-worker-sees-task task)
  (case msg-type
    :compute-factorial (let [r (atom 1)]
                         (doseq [i (range 1 (inc of-integer))]
                           (swap! r * i))
                         (dp :worker-sending-eoj :factorial= @r
                           :on-result-port result-port)
                         (.send result-port {:msg-type :eoj
                                             :value    @r}))
    (dp :WORKER-UNEXPECTED-TASK!!!!!!! task))
  nil)

(defn make-app []
  (let [title "Smooth Clock"]
    (fx/material-app
      {:title title}
      (fx/scaffold
        {:appBar (fx/app-bar {:title (fx/text title)})
         :floatingActionButton
         (fx/floating-action-button
           {:onPressed (fx/as-dart-callback []
                         (wmx-iso
                           (let [fo (fmu :facto-display)]
                             (dp :fab-bumping-fof (minfo fo))
                             (mswap! fo :of + 2))))
            :tooltip   "Send msg"})}
        (fx/column
          (clock-face)
          (fx/text {}
            {:name            :iso-home
             :fx$dpk          [:sstate :build]
             :target          :facto-display
             :result-port     (ReceivePort)
             :also-facto-worker (fn also-facto-worker [{:keys [msg-type of-integer] :as task} result-port]
                                  (dp :stock-worker-sees-task task)
                                  (case msg-type
                                    :compute-factorial (let [r (atom 1)]
                                                         (doseq [i (range 1 (inc of-integer))]
                                                           (swap! r * i))
                                                         (dp :worker-sending-eoj :factorial= @r
                                                           :on-result-port result-port)
                                                         (.send result-port {:msg-type :eoj
                                                                             :value    @r}))
                                    (dp :WORKER-UNEXPECTED-TASK!!!!!!! task))
                                  nil)
             :worker-iso      (cF+ [:async? true
                                    :watch (fn [_ me worker _ _]
                                             (when worker
                                               (dp :got-worker-isolate! worker)))]
                                (let [afw (mget me :also-facto-worker)]
                                  (dp :afw!!!!!! afw)
                                  (Isolate.spawn
                                    (fn [msg]
                                      (dp :stock-worker-sees msg)
                                      (let [{:keys [msg-type ^SendPort result-port]} msg
                                            task-port (ReceivePort)]
                                        (dp :stock-worker-sends-its-receiver-rsn)
                                        (dp :stock-worker-sends-its-receiver (.-sendPort task-port))
                                        (.send result-port {:msg-type  :config
                                                            :task-port (.-sendPort task-port)})
                                        (dp :stock-worker-starts-listening task-port)
                                        (.listen task-port (fn [{:keys [msg-type of-integer] :as task}]
                                                             (dp :stock-afworker-sees-task task)
                                                             ;; (afw task result-port)
                                                             ((:sub-worker msg) task result-port)
                                                             #_(case msg-type
                                                                 :compute-factorial (let [r (atom 1)]
                                                                                      (doseq [i (range 1 (inc of-integer))]
                                                                                        (swap! r * i))
                                                                                      (dp :worker-sending-eoj :factorial= @r
                                                                                        :on-result-port result-port)
                                                                                      (.send result-port {:msg-type :eoj
                                                                                                          :value    @r}))
                                                                 (dp :WORKER-UNEXPECTED-TASK!!!!!!! task))
                                                             nil))
                                        nil))
                                    {:msg-type    :config
                                     :sub-worker  afw #_ (fn [task result-port]
                                                    (facto-worker task result-port))
                                     :result-port (.-sendPort ^ReceivePort (mget me :result-port))}
                                    .errorsAreFatal true
                                    .debugName "make-iso-isolate"))
                                #_(Isolate.spawn
                                    (fn factorial-worker [{:keys [msg-type ^SendPort result-port]}]
                                      (dp :worker-fn-sees msg-type :resport result-port)
                                      (let [task-port (ReceivePort)]
                                        (dp :worker-sends-its-receiver (.-sendPort task-port))
                                        (.send result-port {:msg-type  :config
                                                            :task-port (.-sendPort task-port)})
                                        (.listen task-port
                                          (fn [{:keys [msg-type of-integer] :as task}]
                                            (case msg-type
                                              :compute-factorial (let [r (atom 1)]
                                                                   (do (dpx :startingbillyuns)
                                                                     (dotimes [_ (* #_#_1000 300 1000 10)])
                                                                     (dpx :fini-billions))
                                                                   (doseq [i (range 1 (inc of-integer))]
                                                                     (swap! r * i)
                                                                     (dpx :worker-sending-result :task i :factorial= @r)
                                                                     #_(.send result-port {:msg-type   :factorial
                                                                                           :of-integer i
                                                                                           :value      @r}))
                                                                   (dp :worker-sending-res :factorial= @r)
                                                                   (.send result-port {:msg-type :eoj
                                                                                       :value    @r}))
                                              (dp :WORKER-UNEXPECTED-TASK!!!!!!! task))))))
                                    {:msg-type    :config
                                     :result-port (.-sendPort ^ReceivePort (mget me :result-port))}
                                    .errorsAreFatal true
                                    .debugName "MyIsolate"))
             :result-listener (cF+ []
                                (when (mget me :worker-iso)
                                  (dp :main-starts-listening)
                                  (.listen ^ReceivePort (mget me :result-port)
                                    (fn [message]
                                      (dp :main-hears message)
                                      (case (:msg-type message)
                                        :config (do (dpx :result-config!! message)
                                                  (wmx-iso
                                                    (dpx :main-msets-task-out-port message)
                                                    (mset! me :task-out-port (:task-port message))))
                                        :factorial (dpx :factorial-of (:of-integer message) :is (:value message))
                                        :eoj (do (dp :eoj!!!! message)
                                               (wmx-iso
                                                 (mset! (fmu (mget me :target))
                                                   :factorial (:value message)))
                                               #_#_(.close ^ReceivePort (mget me :result-port))
                                                       (.kill ^Isolate (mget me :worker-iso))))))))
             :task-out-port (cI nil :watch (fn [_ me new _ _]
                                             (dp :task-out-port-now new)))

             :dispatcher (cF (when-let [task-out (mget me :task-out-port)]
                               (fn disp-task [task-n]
                                 (dp :dispatcher-sending-N-to-task-out task-n)
                                 (.send ^SendPort task-out
                                   {:msg-type   :compute-factorial
                                    :of-integer task-n}))))}
            "ISO HOME")
          (fx/text {}
            {:name      :facto-display
             :of        (cI 1 :watch (fn [_ me new _ _]
                                       (when new
                                         (when-let [dispo (mget me :dispo)]
                                           (dp :of-watch-dispoing new)
                                           (dispo new)))))
             :dispo     (cF+ [:watch (fn [_ me dsp-fn _ _]
                                       (when dsp-fn
                                         (dpx :got-disp-fn dsp-fn)))]
                          (mget (fmu :iso-home) :dispatcher))
             :factorial (cI :RSN)}
            (str "The factorial of " (mget me :of) " is " (mget me :factorial))))))))

(defn clock-face []
  (fx/custom-paint
    {:size    (m/Size 400 400)
     :painter (cF (let [tick (mget me :tick)]
                    (reify :extends (m/CustomPainter)
                      (paint [this ^Canvas canvas ^Size size]
                        (let [center (.center size (m/Offset 0 0))
                              radius (- (/ (.-width size) 2) 24)
                              pin-p (doto (m/Paint)
                                      (-> .-color (set! m/Colors.grey.shade400))
                                      (-> .-style (set! m/PaintingStyle.fill)))
                              dial-p (doto (m/Paint)
                                       (-> .-color (set! m/Colors.grey))
                                       (-> .-style (set! m/PaintingStyle.stroke)))
                              hand-p (doto (m/Paint)
                                       (-> .-color (set! m/Colors.red))
                                       (-> .-strokeWidth (set! 1.0))
                                       (-> .-style (set! m/PaintingStyle.stroke)))
                              hand-len (* radius 0.9)
                              hand-angle (/ tick 10.0)
                              hand-end (m/Offset
                                         (+ (.-dx center) (* hand-len
                                                            (cos (/ (* hand-angle pi) 180))))
                                         (+ (.-dy center) (* hand-len
                                                            (sin (/ (* hand-angle pi) 180)))))]
                          ;
                          ; (dp :center center)
                          (.drawCircle ^Canvas canvas center radius dial-p)
                          (.drawLine ^Canvas canvas center hand-end hand-p)
                          (.drawCircle ^Canvas canvas center 10 pin-p)
                          ))
                      (shouldRepaint [this _] true))))}
    {:second (cI 0.6)
     :tick   (cI 0 #_#_:watch (fn [_ me tick _ _]
                                (dp :tick tick)))
     :clock  (cF+ [:on-quiesce (fn [c] (when-let [tmr ^async/Timer (cb/c-value c)]
                                         (.cancel tmr)))]
               (async/Timer.periodic (Duration .milliseconds 10)
                 (fn [^async/Timer tmr]
                   (wmx-iso
                     (mset! me :tick (.-tick tmr))))))}))




; import 'package:flutter/material.dart';
;
;/// Flutter code sample for [TweenAnimationBuilder].
;
;void main() => runApp(const TweenAnimationBuilderExampleApp());
;
;class TweenAnimationBuilderExampleApp extends StatelessWidget {
;  const TweenAnimationBuilderExampleApp({super.key});
;
;  @override
;  Widget build(BuildContext context) {
;    return MaterialApp(
;      home: Scaffold(
;        appBar: AppBar(title: const Text('TweenAnimationBuilder Sample')),
;        body: const Center(
;          child: TweenAnimationBuilderExample(),
;        ),
;      ),
;    );
;  }
;}
;
;class TweenAnimationBuilderExample extends StatefulWidget {
;  const TweenAnimationBuilderExample({super.key});
;
;  @override
;  State<TweenAnimationBuilderExample> createState() =>
;      _TweenAnimationBuilderExampleState();
;}
;
;class _TweenAnimationBuilderExampleState
;    extends State<TweenAnimationBuilderExample> {
;  double targetValue = 24.0;
;
;  @override
;  Widget build(BuildContext context) {
;    return TweenAnimationBuilder<double>(
;      tween: Tween<double>(begin: 0, end: targetValue),
;      duration: const Duration(seconds: 1),
;      builder: (BuildContext context, double size, Widget? child) {
;        return IconButton(
;          iconSize: size,
;          color: Colors.blue,
;          icon: child!,
;          onPressed: () {
;            setState(() {
;              targetValue = targetValue == 24.0 ? 48.0 : 24.0;
;            });
;          },
;        );
;      },
;      child: const Icon(Icons.aspect_ratio),
;    );
;  }
;}