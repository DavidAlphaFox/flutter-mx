(ns tiltontec.example.x020-reactive-stream
  (:require
    ["dart:async" :as async]
    [clojure.string :as str]
    [tiltontec.cell.core :refer [cF cF+ cF_ cI]]
    [tiltontec.cell.observer :refer [fn-obs]]
    [tiltontec.model.core :refer [mget mset! mswap! fm* fmu] :as md]
    [tiltontec.flutter-mx.core :refer [as-dart-callback] :as fx]
    ["package:flutter/widgets.dart" :as w]
    ["package:flutter/material.dart" :as m]
    ["package:flutter/painting.dart" :as p]
    [tiltontec.util.base :refer [dprn dp dpx]]
    [tiltontec.cell.base :refer [cinfo minfo] :as cty]
    [tiltontec.cell.integrity :refer [with-integrity]]))

(def the-second-coming
  ;; with apologies to William Butler Yeats, but we need a duplicate sequence
  (str/split (str "Turning Turning in the widening gyre"
               " The falcon cannot hear the falconer;"
               " Things fall apart; the centre cannot hold;"
               " Mere anarchy is loosed upon the world.") #" "))

(defn make-app []
  (fx/material-app
    {:title "Flutter/MX Stream Demo"
     :theme (m/ThemeData .primarySwatch m.Colors/blue)}
    (fx/scaffold
      {:appBar (fx/app-bar
                 {:title (m/Text "Talking to Myself")})
       :floatingActionButton
       (cF (fx/floating-action-button
             ;; A lot of logic below supports the simple idea that we do not want to "send" a word
             ;; until the user clicks the SMS icon. So we do not start at zero offset, which would
             ;; effectively launch the first word into the stream; instead we start at nil and check
             ;; in a couple of places if we even have a numeric offset.
             {:onPressed (as-dart-callback []
                           ;; as-dart-callback jumps thru necessary interesting hoops
                           ;; to get this code to run when the user presses this widget.
                           (mswap! me :offset #(if % (inc %) 0)))
              :tooltip   "Send next word of message, looping at end"}
             {
              :name       :msg-sender
              :offset     (cI nil)
              ;; if we start at zero, we would broadcast the first word during app startup. Ugh.
              ;; We _could_ model this differently. This is where the MX programmer can be creative.
              ;; Another option might be to have the word stream start as "off", in which case a starting
              ;; offset of zero would be fine: when the stream was turned on, the first word would be sent.
              :next-word  (cF+ [:ephemeral? true
                                ;; "ephemeral" means fleeting. MX uses :ephemeral? to flag state akin to events,
                                ;; things which happen, take effect (propagate thru the DAG), and then are no more.
                                ;; Put another way, they are points in _causation_ time, with no duration.
                                ;; After propagation the property appears as nil, but this is not
                                ;; through a reactive state change from something to nil; the MX internals
                                ;; revert the property to nil internally, without propagation, invisibly to
                                ;; the reactive application rules and the property observer.
                                :watch (fn [_ me new-word _ _]
                                         ;; It is great that the next-word _property_ populates each time the offset
                                         ;; changes, but the Dart stream is not an MX mechanism. It is a pure
                                         ;; Dart mechanism, outside the Matrix. Observers/watches exist precisely
                                         ;; to give MX dataflow effect outside itself, so apps do things.
                                         (when new-word
                                           (.add (.-sink ^#/(async/StreamController String) (mget me :msg-stream))
                                             new-word)))]
                            (when-let [offset (mget me :offset)]
                              (nth the-second-coming (mod offset (count the-second-coming)))))
              :msg-stream (new #/(async/StreamController String))
              }
             (m/Icon m.Icons/chat .color m.Colors/white)))}
      (fx/center
        (fx/column
          {:mainAxisAlignment m.MainAxisAlignment/center}
          (fx/text {:style (p/TextStyle .color m.Colors/black
                             .fontSize 36.0)}
            ;; Next we use FMU, short for "family search Up", instead of FM*, which searches everywhere, up and down.
            ;; This is one place in Matrix that requires careful coding. If we change this next to FM* (try it!),
            ;; we will hit an exception informing us that we are creating a cycle, namely:
            ;;   - this string we are building will be an MX "kid" of the text proxy;
            ;;   - to compute this kid, we ask MX to search the _whole_ MX for :msg-recipient;
            ;;   - the search utility then asks this text widget for its child, which is being computed(!);
            ;; That is a cycle. We avoid it by telling the utility to search only above this node.
            (str "Message " (or (mget (fmu :msg-recipient) :msg-ct) "not") " received:"))

          (fx/text!
            {:style (fx/in-my-context [me ctx]
                      ;; access to the Flutter context is not straightforward.
                      ;; Macro `in-my-context` handles the complexity of accessing the context.
                      (.-headline3 (.-textTheme (m.Theme/of ctx))))}
            ;; We pause to call out what we have seen before: next we are able to provide a generic text proxy instance
            ;; with several custom attributes. This is the prototype model of objects.
            ;; The prototype model avoids the OO trap of forever having to subclass instances when we need to extend
            ;; their capabilities, to achieve desired app behavior.
            {:name :msg-recipient
             :msg-source   (cF+ [;; todo new Stream Cell type, or :stream? option
                                 ;; This to-do ^^^ means we suspect streams will be common enough to support
                                 ;; with an MX extension, to hide the stream handling boilerplate.
                                 :watch (fn [_ me ^#/(async/StreamController String) new-source old-source _]
                                          ;; todo when old-source, unlisten it
                                          ;; We have retrieved the :msg-stream Dart stream and have it as Cell value.
                                          ;; Super. But, now we need to do some wiring to connect the non-MX stream to the MX DAG.
                                          ;; 1. listen to the stream and...
                                          ;; 2. ...provide a listener which writes to an "input" Cell in the DAG.
                                          (.listen (.-stream ^#/(async/StreamController String) new-source)
                                            (fn [^String msg]
                                              (with-integrity [:change :msg-rcvd]
                                                (mset! me :msg-rcvd msg)))))]
                             (mget (fm* :msg-sender) :msg-stream))

             :msg-rcvd (cI "<none>"
                         ;; again we flag a property as state _events_
                         :ephemeral? true)

             :msg-ct (cF (when-let [msg (mget me :msg-rcvd)]
                           (when-not (or (str/blank? msg)
                                       (= msg "<none>"))
                             ;; normally formulae calculate without regard to the past, but they
                             ;; _do_ have access to their prior value calculated in the anaphor "cache".
                             (if _cache (inc _cache) 1))))
             }
            (mget me :msg-rcvd)))))))