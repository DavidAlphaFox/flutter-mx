(ns tiltontec.mx-flutter.tag
  (:require ["package:flutter/material.dart" :as m
             :refer [MaterialApp Widget Scaffold MainAxisAlignment Colors Theme
                     FloatingActionButton Icon Icons ThemeData runApp AppBar State]]
            ["package:flutter/widgets.dart" :as w
             :refer [Text Center Expanded Column State StatefulWidget StatelessWidget]]
            ["package:flutter/painting.dart" :as p
             :refer [TextStyle]]
            [tiltontec.util.base :refer [dprn dp dpx]]
            [tiltontec.cell.base :refer [mx-type minfo cinfo unbound Model PObserver observe md-ref?] :as cty]
            [tiltontec.cell.core
             :refer [cF cF+ c-reset-next! cFonce cFn cI c-reset! make-cell make-c-formula]]
            [tiltontec.util.core :as util
             :refer [atom? rmap-setf err rmap-meta-setf set-ify difference]]
            [tiltontec.model.core :refer [make mget md-kids mswap! cFkids] :as md]))

(deftype MXFXAsIs [value]
  ;; tells fx-resolve to leave mx value untouched
  ;; used originally so a FX callback (the builder for AnimatedBuilder) was not
  ;; treated as callback to MX to get the resolved value.
  :extends cty/MXImplementer)

(deftype MXFXCallback [value]
  ;; tells fx-resolve to call the mx value as a function of ctx and me.
  ;; used where app needs to see the Flutter context to decide a value
  :extends cty/MXImplementer)

(defprotocol PDartWidget
  (parts [this] "eg, Scaffold [:appBar :body :floatingActionButton ...]")
  (parts-ex [this count] "Test")
  (beefer [this])
  (fx-genner [this]))

(defn fx-resolve
  ([me ctx widget-value]
   (fx-resolve :anon me ctx widget-value))
  ([slot me ctx widget-value]
   (cond
     (nil? widget-value)
     (do                                                    ;; (dp :exwid-sees-nil-widget-value)
       nil)

     (dart/is? widget-value MXFXAsIs)
     (do
       (dp :fx-reseolve-as-ising!!!!!!!!! slot (minfo me) widget-value)
       (.-value widget-value))

     (dart/is? widget-value MXFXCallback)
     (do
       (dp :fx-reso-calling-back!!!!!!! slot (minfo me) widget-value)
       ((.-value widget-value)))


     (dart/is? widget-value m/Widget)
     (do                                                    ;; (dp :widget-value-is-widget widget-value)
       widget-value)

     (fn? widget-value)
     (do
       (dp :DEPRECATED!!!-unwrapped-fn!! slot (minfo me))
       (recur slot me ctx (widget-value me ctx)))

     (cty/md-ref? widget-value)
     (do
       (recur slot me ctx
         (render-fx ctx widget-value)))

     :default widget-value)))

(defn render-fx [ctx fx]
  ;; todo reverse params? awkward for many calls where fx is complex
  (dpx :rfx-entry ctx (cty/minfo fx))
  (cond
    (not (md-ref? fx))
    (do                                                     ;; (dprn :rnfx-sees-not-md-ref?-passing-thru fx)
      fx)
    :else (let [gen (mget fx :fx-gen)]
            (assert gen "OBAD: render-fx of model finds no fx-gen: ")
            (gen fx ctx))))

(defmacro with-ctx [[me-var ctx-var] & body]
    `(fn [~me-var ~ctx-var]
       ~@body))

(defmacro with-ctx-cb [[me-var ctx-var] & body]
  `(tiltontec.mx-flutter.tag/MXFXCallback
     (fn [~me-var ~ctx-var]
       ~@body)))

(defn fx-state-nearest [me]
  (when me
    (or ^State? (mget me :fx$state)
      (fx-state-nearest (md/mpar)))))

(defmacro with-my-ctx [[ctx-var] & body]
  `(let [^State state# (tiltontec.mx-flutter.tag/fx-state-nearest ~'me)]
     (assert state# (str "no fxstate in or above " (minfo ~'me)))
     (assert (.context state#) (str "with-my-ctx-sees-state-not-context " state# " " (minfo ~'me)))
     (let [~ctx-var (.context state#)]
       ~@body)))

(defmacro when-my-state [[state-var] & body]
  `(when-let [~state-var (fxx/my-state)]
     ~@body))

(defn statefully [me beefer]
  (reify :extends w/StatefulWidget
    (createState [this]
      ;; (dp :creatingstate!!! (minfo me))
      (util/rmap-meta-setf [:state-ref me]
        (reify :extends w/State
          ^:mixin m/SingleTickerProviderStateMixin
          (build [this ctx]
            ;; the current use of statefully is to pass along as the beefer either
            ;; one defined with the MX instance or one provided by the FXType as beefer.
            ;; So can we just let the FXType always define builders?
            ;;
            ;; we include the MX "me" in the generation...
            (assert (= ctx (.context this)))
            (md/mset! me :fx$ctx ctx)
            (beefer me ctx))
          (^void initState [this]
            (.initState ^super this)
            (rmap-meta-setf [:context me] (.context this))
            (when-let [init (mget me :initState)]
              (init this me)))
          (^void dispose [this]
            (when-let [disp-fn (mget me :dispose)]
              (disp-fn this me))
            (.dispose ^super this)))))))

(defn make-fx [mx-type fx-props custom-props cFkids-form]
  ;;(dp :make-fx!!!!!!! mx-type)
  (apply tiltontec.model.core/make
    :mx-type mx-type
    :kids cFkids-form
    :fx$ctx (cI nil)                                        ;; set at start of build
    :fx-prop-keys (keys fx-props)
    :fx-gen (fn [me ctx]
              ;; the default "statefully" works for must Flutter widgets,
              ;; but not all, such as AppBar which cannot be wrapped under Scaffold,
              ;; so we allow individual widget Types to supply their own fx-gen.
              (if-let [type-fx-gen (fx-genner mx-type)]     ;; <- override option
                (type-fx-gen me ctx)
                ; --- no special fx gen, so...the default:
                (tiltontec.mx-flutter.tag/statefully me
                  (fn [me ctx]
                    (let [beefer (or (mget me :beefer)
                                   (beefer mx-type))]
                      ;; (dp :make-fx-using-beefer!!!!!!!! (minfo me) beefer)
                      (beefer me ctx))))))
    (concat
      (vec (apply concat (seq fx-props)))
      (vec (apply concat (seq custom-props))))))

(defmacro deftag [tag fx-type-name]
  ;;(dprn :deftag-entry!!!!!!! tag fx-type-name)
  `(defmacro ~tag [& vargs#]
     ;;(dprn :expanding-deftag '~tag)
     (let [fx-type# '~fx-type-name]
       (cond
         (nil? vargs#)
         `(tiltontec.mx-flutter.tag/make-fx (new ~fx-type#)
            {} {} nil)

         (not (map? (first vargs#)))
         (do                                                ;;(dprn :just-kids!!!!!!!! '~tag)
           ;; we must have justkids
           `(tiltontec.mx-flutter.tag/make-fx (new ~fx-type#)
              {} {}
              (tiltontec.model.core/cFkids ~@vargs#)))

         (map? (second vargs#))
         ;; full spec, maybe kids
         (do                                                ;;(dprn :full-spec!!!!!!!!!!!! (second vargs#))
           `(tiltontec.mx-flutter.tag/make-fx (new ~fx-type#)
              ~(first vargs#)
              ~(second vargs#)
              ~(when-let [kids# (seq (nthrest vargs# 2))]
                 `(tiltontec.model.core/cFkids ~@kids#))))

         :else                                              ;; just first map of fx props and maybe kids
         `(tiltontec.mx-flutter.tag/make-fx (new ~fx-type#)
            ~(first vargs#)
            {}
            ~(when-let [kids# (seq (nthrest vargs# 1))]
               `(tiltontec.model.core/cFkids ~@kids#)))))))


