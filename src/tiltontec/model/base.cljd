(ns tiltontec.model.base
  (:require
    [tiltontec.matrix.foundation :refer [observe]]
    [tiltontec.matrix.base
     :refer [trx wtrx dprn dp dpx prog1 *trx?* def-rmap-props def-rmap-meta-props]]
    [tiltontec.matrix.util :refer [err rmap-set! rmap-meta-set!]]

    [tiltontec.cell.base
     :refer [without-c-dependency cells-init c-optimized-away? c-formula? c-value c-optimize
             c-unbound? c-input?
             c-model c-valid? c-useds c-ref?
             c-state +pulse+ c-pulse-observed c-assert
             *call-stack* *defer-changes* unbound
             c-rule c-me c-value-state c-callers
             unlink-from-callers *causation* c-mname
             c-synaptic? c-quiesce!
             c-pulse c-pulse-last-changed c-ephemeral? c-prop c-lazy] :as cty]
    [tiltontec.cell.evaluate :refer [cget c-awaken]]
    [tiltontec.model.peek :refer [minfo md-type mref? mname *md-quiescing*]]
    ))

(def ^:dynamic *md-host*
  "used for navigation above `me` for delegate MX nodes with no parent, such as an appBar"
  nil)

(def-rmap-props md-
  name)

(def-rmap-meta-props md-
  state cz)

(defn md-cell [me prop]
  (prop (md-cz me)))

;;; --- md initialization ---

;; (declare md-awaken)

(defn md-install-cell [me prop c]
  ;; note that c might not be a Cell; it is a misnomer
  (cond
    (c-ref? c) (do
                 (swap! c assoc
                   :prop prop
                   :me me)
                 (rmap-set! [prop me]
                   (when (c-input? c)
                     (c-value c)))
                 true)
    :else (do
            (rmap-set! [prop me] c)
            false)))

(defn md-awaken
  "(1) do initial evaluation of all ruled slots
   (2) call observers of all slots"
  [me]

  (assert me "md-awaken is nil")
  ;(dp :md-awaken-me!! (cty/minfo me))
  ;(prn :md-awaken-meta!! (meta me))
  ;(prn :md-awaken-deref!! (deref me))

  (assert (= :nascent (md-state me))
    (str "md-awaken> incoming md-state not= :nascent, it is" (md-state me)))

  (wtrx [0 999 :awk-entry (minfo me)]
    (rmap-meta-set! [:state me] :awakening)
    (binding [*md-host* me]
      (doall
        (for [prop (keys @me)]
          ;; next is tricky: if prop is in :cz but nil, it has been
          ;; optimized-away and observed then in the rare case
          ;; it gets optimized away on other than the initial
          ;; value.
          (when-let [c (prop (md-cz me) :not-found)]
            (cond
              (= c :not-found)
              ;; these need at least an initial observe
              (when (not (some #{prop} [:parent :name :fx-gen :on-quiesce]))
                (observe (md-type me) prop me (prop @me) unbound nil))
              :else (when-not (= (c-state c) :awake)        ;; might have happened already
                      (c-awaken c)))))))
    (rmap-meta-set! [:state me] :awake)
    me))

;; --- md-quiesce --

(defn md-quiesce-self! [me]
  (wtrx [0 999 :mdq-self (minfo me)]
    (when-let [onq (get @me :on-quiesce)]
      (wtrx [0 999 :mdq-onq (minfo me)]
        (onq me)))

    (doseq [c (vals (:cz (meta me)))]
      (when c                                               ;; not if optimized away
        (c-quiesce! c)))

    (doseq [k (keys @me)]
      (when-not (some #{k} [:parent :host])
        (when-let [v (get @me k)]
          (when (or (mref? v)
                  (and (coll? v) (mref? (first v))))
            (dp :blindly-md-quiescing k)
            (md-quiesce! (get @me k))))))

    (reset! me (concat [:quiesced] [(minfo me)]))
    (rmap-meta-set! [:state me] :quiesced)))

(defn md-quiesce! [me]
  ;; todo this means we have to ensure that :on-quiesce is just a function, not a cell
  (wtrx [0 999 :mdq-entry (minfo me)]
    (binding [*md-quiescing* true]
      (cond
        (and (coll? me) (mref? (first me)))
        (doseq [elt me]
          (md-quiesce! elt))

        :else (when (mref? me)
                (md-quiesce-self! me))))))

