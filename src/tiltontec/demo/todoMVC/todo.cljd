(ns tiltontec.demo.todoMVC.todo
  (:require
    [clojure.walk :as walk]

    [tiltontec.util.base :refer [dprn dp dpx]]
    [tiltontec.util.core :as util]
    [tiltontec.cell.base :refer [cinfo minfo] :as cty]
    [tiltontec.cell.core :refer [cF cFn cF+ cF_ cI c_F cFonce]]
    [tiltontec.model.core :refer [mget] :as md]

    ["package:flutter/widgets.dart" :as w]
    ["package:flutter/material.dart" :as m]
    ["dart:convert" :as convert]
    ["package:localstore/localstore.dart" :as ls]
    [tiltontec.mx-flutter.store :as store]))

(defn title-red []
  (.fromRGBO m/Color 184 63 69 0.5))

(def todo-sid (atom 0))

(declare td-delete)

(defn td-ls-id [td] (mget td :ls-id))
(defn td-sid [td] (mget td :sid))
(defn td-title [td] (mget td :title))
(defn td-completed [td] (mget td :completed))

(deftype ToDoList []
  :extends cty/Model
  cty/PObserver
  (observe [this slot me new-value prior-value cell]
    ;; no need to observer initial value observation, when prior is unbound

    (case slot
      :kids (when (not= cty/unbound prior-value)
              (let [lost (util/difference (set prior-value) (set new-value))]
                (dp :lost-TDs!!!! lost)
                (dp :lost-TDs!!!! (map td-ls-id lost))
                (await (doseq [td lost]
                         (dp :deleting=TD (td-ls-id td))
                         (await (td-delete "todo" (td-ls-id td)))))))
    )))

(defn make-todo-list
  ([name] (make-todo-list name nil))
  ([name existing-todos]
   (dp :make-tdl-entry name (count existing-todos))
   (md/make
     :mx-type (ToDoList.)
     :name name
     :kids (cFn (dp :maketdl-kids-rule-sees!!! (count existing-todos) (minfo me))
             (mapv (fn [xtd]
                     (dp :make-td!!!!!!! xtd)
                     (let [{:keys [title completed ls-id sid]} xtd]
                       (make-todo me title completed sid ls-id)))
               existing-todos)))))

(declare td-upsert)



(defn td-initialize [collection-name td-map]
  (dp :td-init!!! collection-name td-map)
  (assert (not (:ls-id td-map)) "td-map already written")   ;; already written
  (.ensureInitialized w/WidgetsFlutterBinding)
  (let [db (.-instance ls/Localstore)
        coll (.collection db collection-name)
        new-id (.-id (.doc coll))
        new-data (assoc td-map :ls-id new-id)]
    (dp :td-init-making-new-LS new-id new-data)
    (-> coll
      (.doc new-id)
      (.set (walk/stringify-keys new-data)))
    new-id))

(defn td-rewrite [collection-name td-map]
  (.ensureInitialized w/WidgetsFlutterBinding)
  (let [db (.-instance ls/Localstore)
        coll (.collection db collection-name)
        ls-id (:ls-id td-map)]
    (assert ls-id "td-rewrite map must include ls-id")
    (await (-> coll
             (.doc ls-id)
             (.set (walk/stringify-keys td-map))))
    (dp :td-rewrite-COMPLETE ls-id)
    ls-id))

(defn td-delete [collection-name ls-id]
  (.ensureInitialized w/WidgetsFlutterBinding)
  (let [db (.-instance ls/Localstore)
        coll (.collection db collection-name)]
    (assert ls-id "td-delete requires ls-id")
    (dp :td-delete-START ls-id)
    (await (-> coll
             (.doc ls-id)
             .delete))
    (dp :td-delete-COMPLETE ls-id)
    ls-id))

#_
(defn td-upsert [td]
  (assert (cty/md-ref? td))
  (dpx :td-upserting!!!! (td-ls-id td) @td)
  (assert (mget td :par))
  (let [coll-name (mget (mget td :par) :name)]
    (.ensureInitialized w/WidgetsFlutterBinding)
    (if (td-ls-id td)                                       ;; (mget td :ls-id)
      (dp :td-upsert-FNY-not-yet-UPDATING-lsid!!! @td)
      (let [db (.-instance ls/Localstore)
            coll (.collection db coll-name)
            new-id (.-id (.doc coll))
            new-data (assoc (select-keys @td [:title :completed :sid])
                       :ls-id new-id)]
        (dp :td-upsert-making-new!!-NOT new-id new-data)
        (-> coll
          (.doc new-id)
          (.set (walk/stringify-keys new-data)))))))

(deftype ToDo []
  :extends cty/Model
  cty/PObserver
  (observe [this slot me new-value prior-value cell]
    (when (and (td-ls-id me) (not= cty/unbound prior-value))
      ;; arbitrary choice; we really want to observe "any change"
      (dp :FNY-UPDATE!!!!!! slot (minfo me))
      #_(td-upsert me))))

(defn make-todo
  ([td-lst title completed]
   (make-todo td-lst title completed
     (swap! todo-sid inc) nil))
  ([td-lst title completed sid ls-id]
   (md/make
     :par td-lst
     :mx-type (ToDo.)
     :sid sid
     :ls-id (or ls-id
              (td-initialize "todo"
                {:sid       sid
                 :title     title
                 :completed completed}))
     ;--
     :title (cI title)
     :completed (cI completed))))

;(md/def-md-slots td- sid ls-id title completed)



(defn td-upsert [td]
  (assert (cty/md-ref? td))
  (dpx :td-upserting!!!! (td-ls-id td) @td)
  (assert (mget td :par))
  (let [coll-name (mget (mget td :par) :name)]
    (.ensureInitialized w/WidgetsFlutterBinding)
    (if (td-ls-id td)                                       ;; (mget td :ls-id)
      (dp :td-upsert-FNY-not-yet-UPDATING-lsid!!! @td)
      (let [db (.-instance ls/Localstore)
            coll (.collection db coll-name)
            new-id (.-id (.doc coll))
            new-data (assoc (select-keys @td [:title :completed :sid])
                       :ls-id new-id)]
        (dp :td-upsert-making-new!!-NOT new-id new-data)
        (-> coll
          (.doc new-id)
          (.set (walk/stringify-keys new-data)))))))

;;; --- higher level ---------------------------

(defn td-list-load
  "returns a future; await to get full-blown todos"
  [name]
  (let [store-tds (await (store/read-all-docs name))]
    (dp :tdlistload-sees-doc-count (count store-tds))
    (let [td-lst (make-todo-list name store-tds)]
      (dp :tdlistload-made-list!!!!!!!! @td-lst)
      td-lst)))

;;; --- even higher level ---------------------------------------

(defn app-todos [app]
  ;; we have to wait for async load of the to-do collection from localstorage
  (assert app "at no app")
  (assert (cty/md-ref? app))
  (when-let [td-lst (tiltontec.model.core/mget app :todo-db)]
    (assert (cty/md-ref? td-lst))
    (tiltontec.model.core/mget td-lst :kids)))