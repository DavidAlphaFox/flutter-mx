(ns tiltontec.demo.todoMVC.todo
  (:require
    [clojure.walk :as walk]

    [tiltontec.util.base :refer [dprn dp dpx]]
    [tiltontec.util.core :as util]
    [tiltontec.cell.base :refer [cinfo minfo] :as cty]
    [tiltontec.cell.core :refer [cF cFn cF+ cF_ cI c_F cFonce]]
    [tiltontec.model.core :refer [mget] :as md]

    ["package:flutter/widgets.dart" :as w]
    ["package:flutter/material.dart" :as m]
    ["dart:convert" :as convert]
    ["package:localstore/localstore.dart" :as ls]
    [tiltontec.mx-flutter.store :as store]))

(defn title-red []
  (.fromRGBO m/Color 184 63 69 0.5))

(def todo-sid (atom 0))

(declare td-delete)

(defn td-ls-id [td] (mget td :ls-id))
(defn td-sid [td] (mget td :sid))
(defn td-title [td] (mget td :title))
(defn td-completed [td] (mget td :completed))

(deftype ToDoList []
  :extends cty/Model
  cty/PObserver
  (observe [this slot me new-value prior-value cell]
    ;; no need to observer initial value observation, when prior is unbound

    (case slot
      :kids (when (not= cty/unbound prior-value)
              (let [lost (util/difference (set prior-value) (set new-value))]
                (dp :lost-TDs!!!! lost)
                (dp :lost-TDs!!!! (map td-ls-id lost))
                (await (doseq [td lost]
                         (dp :deleting=TD (td-ls-id td))
                         (await (td-delete "todo" (td-ls-id td)))))))
      )))

(defn make-todo-list
  ([name] (make-todo-list name nil))
  ([name existing-todos]
   (md/make
     :mx-type (ToDoList.)
     :name name
     :kids (cFn (mapv (fn [xtd]
                        (let [{:keys [title completed ls-id sid]} xtd]
                          (make-todo me title completed sid ls-id)))
                  existing-todos)))))

(defn td-initialize [collection-name td-map]
  (assert (not (:ls-id td-map)) "td-map already written")   ;; already written
  (.ensureInitialized w/WidgetsFlutterBinding)
  (let [db (.-instance ls/Localstore)
        coll (.collection db collection-name)
        new-id (.-id (.doc coll))
        new-data (assoc td-map :ls-id new-id)]
    (-> coll
      (.doc new-id)
      (.set (walk/stringify-keys new-data)))
    new-id))

(defn td-rewrite [collection-name td-map]
  (.ensureInitialized w/WidgetsFlutterBinding)
  (let [db (.-instance ls/Localstore)
        coll (.collection db collection-name)
        ls-id (:ls-id td-map)]
    (assert ls-id "td-rewrite map must include ls-id")
    (await (-> coll
             (.doc ls-id)
             (.set (walk/stringify-keys td-map))))
    ls-id))

(defn td-update [td]
  (assert (cty/md-ref? td))
  (assert (td-ls-id td))
  (dp :td-updating!!!! (td-ls-id td) @td)
  (assert (mget td :par))
  (let [coll-name (mget (mget td :par) :name)]
    (.ensureInitialized w/WidgetsFlutterBinding)
    (let [db (.-instance ls/Localstore)
          coll (.collection db coll-name)
          new-data (select-keys @td [:ls-id :title :completed :sid])]
      (-> coll
        (.doc (td-ls-id td))
        (.set (walk/stringify-keys new-data))))))

(defn td-delete [collection-name ls-id]
  (.ensureInitialized w/WidgetsFlutterBinding)
  (let [db (.-instance ls/Localstore)
        coll (.collection db collection-name)]
    (assert ls-id "td-delete requires ls-id")
    (await (-> coll
             (.doc ls-id)
             .delete))
    ls-id))

(deftype ToDo []
  :extends cty/Model
  cty/PObserver
  (observe [this slot me new-value prior-value cell]
    (when (and (td-ls-id me) (not= cty/unbound prior-value))
      (td-update me))))

(defn make-todo
  ([td-lst title completed]
   (make-todo td-lst title completed
     (swap! todo-sid inc) nil))
  ([td-lst title completed sid ls-id]
   (md/make
     :par td-lst
     :mx-type (ToDo.)
     :sid sid
     :ls-id (or ls-id
              (td-initialize "todo"
                {:sid       sid
                 :title     title
                 :completed completed}))
     ;--
     :title (cI title)
     :completed (cI completed))))

;;; --- higher level ---------------------------

(defn td-list-load
  "returns a future; await to get full-blown todos"
  [name]
  (make-todo-list name
    (await (store/read-all-docs name))))

;;; --- even higher level ---------------------------------------

(defn app-todos [app]
  ;; we have to wait for async load of the to-do collection from localstorage
  (assert app "at no app")
  (assert (cty/md-ref? app))
  (when-let [td-lst (tiltontec.model.core/mget app :todo-db)]
    (assert (cty/md-ref? td-lst) (str "app-todos> td-lst not md-ref? " td-lst))
    (md/mkids td-lst)))