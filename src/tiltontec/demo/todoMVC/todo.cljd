(ns tiltontec.demo.todoMVC.todo
  (:require
    ["package:flutter/widgets.dart" :as w]
    ["package:flutter/material.dart" :as m]
    ["dart:convert" :as convert]
    ["package:localstore/localstore.dart" :as ls]
    ["package:shared_preferences/shared_preferences.dart" :as prefs]
    [clojure.walk :as walk]

    [tiltontec.util.base :refer [dprn dp dpx]]
    [tiltontec.util.core :as util]
    [tiltontec.cell.base :refer [cinfo minfo] :as cty]
    [tiltontec.cell.core :refer [cF cFn cF+ cF_ cI c_F cFonce] :as cells]
    [tiltontec.model.core :refer [mget mpar mkids mname] :as md]
    [tiltontec.mx-flutter.store :as store]
    [tiltontec.demo.todoMVC.store-pref :as stg]))

;;; --- should be in a utils file ----------------------
(defn title-red []
  (.fromRGBO m/Color 184 63 69 0.5))

(defmacro my-app []
  ;; fasc "captures" 'me
  `(tiltontec.model.core/fasc :app))

(defmacro my-app-db []
  ;; fasc "captures" 'me
  `(tiltontec.model.core/mget
     (tiltontec.model.core/fasc :app) :db))

(defmacro my-todo-list []
  `(tiltontec.model.core/mget (tiltontec.model.core/fasc :app) :todo-list))

;;; --- handy accessors ---------------------------------

(defn td-stg-id [td] (mget td :stg-id))                     ;; LS only?
(defn td-title [td] (or (mget td :title) ""))
(defn td-completed [td] (or (mget td :completed) false))

;;; --- FX-level to-dos and to-do list -----------------------------------------

(declare ToDo-update)

(deftype ToDo []
  :extends cty/Model
  cty/PObserver
  (observe [this slot me new-value prior-value cell]
    (when (and (td-stg-id me) (not= cty/unbound prior-value))
      (ToDo-update me))))

(defn make-ToDo
  ([td-lst title completed]
   (make-ToDo td-lst title completed nil))
  ([td-lst title completed stg-id]
   (md/make
     :par td-lst
     :mx-type (ToDo.)
     :stg-id (or stg-id
               (stg/td-initialize "todo"
                 {:title     title
                  :completed completed}))
     ;--
     :title (cI title)
     :completed (cI completed))))

(defn ToDo-update [td]
  (let [coll-name (mname (mpar td))]
    (stg/td-rewrite coll-name (select-keys @td [:stg-id :title :completed]))))

;;; --- higher level ---------------------------

(deftype ToDoList []
  :extends cty/Model
  cty/PObserver
  (observe [this slot me new-value prior-value cell]
    (case slot
      :kids (when (not= cty/unbound prior-value)
              (let [lost (util/difference (set prior-value) (set new-value))]
                (doseq [td lost]
                  (stg/td-delete "todo" (td-stg-id td))))))))

;; todo show todos in order; add created slot

;; todo ??? move fx$state to meta and get out of dataflow
;;      this will entail new way to get controller

;; todo !!!!!!!!!!!!!!!!!! can futures be handled better?

(defn make-ToDoList
  ([name] (make-ToDoList name nil))
  ([name existing-todos]
   (md/make
     :mx-type (ToDoList.)
     :name name
     :kids (cFn (mapv (fn [xtd]
                     (let [{:keys [title completed stg-id]} xtd]
                       (make-ToDo me title completed stg-id)))
               existing-todos)))))


;;; --- even higher level ---------------------------------------

(defn app-todos [app]
  (when-let [td-lst (tiltontec.model.core/mget app :todo-list)]
    ;; we have to wait for todos to be loaded from localstorage
    (assert (cty/md-ref? td-lst) (str "app-todos> td-lst not md-ref? " td-lst))
    (md/mkids td-lst)))