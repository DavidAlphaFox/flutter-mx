(ns tiltontec.test.storage-test
  (:require
    ["dart:developer" :as dev]
    ["dart:math" :as mth]
    ["dart:convert" :as convert]
    [tiltontec.util.base :refer [dprn dp dpx]]
    [tiltontec.model.core :refer [mget mswap!] :as md]
    ;;[tiltontec.mx-flutter.core :as fx]
    ["package:localstore/localstore.dart" :as ls]
    ["package:flutter/widgets.dart" :as w]
    [tiltontec.mx-flutter.store :as store]
    [tiltontec.demo.todoMVC.todo :as todo]
    [clojure.walk :as walk]))

(defn just-hack []
  (.ensureInitialized w/WidgetsFlutterBinding)
  ;;; --- read all docs ---------------------------
  (let [id "1isb6j40s"
        db (.-instance ls/Localstore)
        rb (await (-> db
                    (.collection "todos")
                    (.doc id)
                    .get))]
    (dp :readback!!!!!! id :data (string? rb) (map? rb) :raw> rb)
    (dp :readback!!!!!! id :keys!!! (keys rb) rb)
    (dp :CLJD-map!!!! (walk/keywordize-keys
                        (into {}
                          (for [k (keys rb)]
                            [k (get rb k)]))))
    (dp :deleteing!!!!!!!)
    (let [db (await (-> db
                      (.collection "todos")
                      (.doc id)
                      .delete))]
      (dp :dlete-says db))
    ))



(defn test-store-one-map []
  (.ensureInitialized w/WidgetsFlutterBinding)
  (let [db (.-instance ls/Localstore)]
    ;;; --- write new entry -----------------------------
    (let [coll (.collection db "todos")
          new-id (.-id (.doc coll))]
      (dp :creating-new-to!! new-id)
      (-> db
        (.collection "todos")
        (.doc new-id)
        (.set (walk/stringify-keys
                {:title     "Todo title Two"
                 :weight    174.3
                 :completed false})))

      ;;; --- read known IDs ------------------------------
      (doseq [id [new-id] #_["5ggmwupfb" "3n3aym16h"]]
        (let [rb (await (-> db
                          (.collection "todos")
                          (.doc id)
                          .get))]
          (dp :readback!!!!!! id :data (string? rb) (map? rb) :raw> rb)
          (dp :readback!!!!!! id :keys!!! (keys rb) rb)
          (dp :CLJD-map!!!! (walk/keywordize-keys
                              (into {}
                                (for [k (keys rb)]
                                  [k (get rb k)])))))))))

(defn load-test-todos []
  (dp :loading!!!!!!!!-todos-not)

  (.ensureInitialized w/WidgetsFlutterBinding)
  (dp :initialized!!!!!-todos)

  ;(.ensureInitialized w/WidgetsFlutterBinding)

  #_(let [test-todos [{:title     "Wash car"
                       :completed false}
                      {:title     "Wash dog"
                       :completed true}
                      {:title     "Walk dog"
                       :completed false}]
          db (.-instance ls/Localstore)
          coll (.collection db "todo")]
      (doseq [{:keys [title completed]} test-todos]
        (md/make-ls
          :mx-type (ToDo)
          :title title
          :completed completed))
      )

  ;;; --- read known IDs ------------------------------
  (let [db (.-instance ls/Localstore)]
    (doseq [id ["5ggmwupfb" "3n3aym16h"]]
      (let [rb (await (-> db
                        (.collection "todos")
                        (.doc id)
                        .get))]
        (dp :readback!!!!!! id :data (string? rb) (map? rb) :raw> rb)
        (dp :readback!!!!!! id :keys!!! (keys rb) rb)
        (dp :CLJD-map!!!! (walk/keywordize-keys
                            (into {}
                              (for [k (keys rb)]
                                [k (get rb k)]))))
        #_(dp :readback!!!!!! id :decode!! (convert/jsonDecode rb) rb)))

    (doseq [id ["5ggmwupfb" "3n3aym16h"]]
      (let [rb (walk/keywordize-keys
                 (into {}
                   (await (-> db
                            (.collection "todos")
                            (.doc id)
                            .get))))]
        (dp :re22222!!!!!! id :data (string? rb) (map? rb) :raw> rb)
        (dp :re22222k!!!!!! id :keys!!! (keys rb) rb)
        (dp :CLJD-map!!!! rb)
        #_(dp :readback!!!!!! id :decode!! (convert/jsonDecode rb) rb))))

  ; (def items
  ;  (-> (await db)
  ;      (.collection "todos")
  ;      .get))

  #_(let [rb (await (-> db
                      (.collection "todos")
                      (.doc id)
                      .get))]
      (dp :readback!!!!!!!!! id :data rb)))


(comment

  ;(dp :jsowrite!!!!! (json/write-str {:a 1 :b 2}))
  ;(dp :jsoencode (convert/jsonEncode {:a 1 :b 2}))


  (let [db (.-instance ls/Localstore)]
    (dp :bam-db!!!!!!!!!!! db)

    ;
    ; 3n3aym16h
    ; 5ggmwupfb
    ;
    (let [coll (.collection db "todos")
          ;id (.id (.doc (.collection db "todos")))
          ;;id #_ "5ggmwupfb"  (.id (.doc coll))
          ]
      (dp :BAM-coll coll)
      (dp :BAM-doc-get-all (await (.get coll)))
      #_(dp :BAM-doc-get-all-decode (convert/jsonDecode
                                      (await (.get coll))))
      ;;(dp :BAM-doc-id id)

      ;;; --- write new entry -----------------------------
      (let [coll (.collection db "todos")
            new-id (.id (.doc coll))]
        ;;id #_ "5ggmwupfb"  (.id (.doc coll))
        (-> db
          (.collection "todos")
          (.doc new-id)
          (.set {"title" "Todo title Two"})))

      ;;; --- read known IDs ------------------------------
      (doseq [id ["5ggmwupfb" "3n3aym16h"]]
        (let [rb (await (-> db
                          (.collection "todos")
                          (.doc id)
                          .get))]
          (dp :readback!!!!!! id :data (string? rb) (map? rb) :raw> rb)
          (dp :readback!!!!!! id :keys!!! (keys rb) rb)
          (dp :CLJD-map!!!! (walk/keywordize-keys
                              (into {}
                                (for [k (keys rb)]
                                  [k (get rb k)]))))
          #_(dp :readback!!!!!! id :decode!! (convert/jsonDecode rb) rb)))

      ;;  Unhandled Exception: type '_InternalLinkedHashMap<String, dynamic>' is not a subtype of type 'String' in type cast

      #_(let [rb (await (-> db
                          (.collection "todos")
                          (.doc id)
                          .get))]
          (dp :readback!!!!!!!!! id :data rb)))))



;(dp :jsowrite!!!!! (json/write-str {:a 1 :b 2}))
;(dp :jsoencode (convert/jsonEncode {:a 1 :b 2}))
#_(let [decode (convert/jsonDecode "{ \"name\": \"Pizza da Mario\", \"cuisine\": \"Italian\" }")]
    (dp :decodes? (string? decode))
    (dp :decodes-map? (map? decode))
    (dp :decodes-keywordized (walk/keywordize-keys decode))
    (dp :decode-k (keys decode))
    (dp :cuisi (get decode "cuisine"))
    (dp :decode decode)

    (doseq [[k v] decode]
      (dp :doseq k v)
      (dp :doseq (keyword k) v)
      )

    (dp :forrrrr (into {}
                   (for [[k v] decode]
                     [(keyword k) v])))
    #_(let [mp (into {}
                 (apply concat
                   (for [[k v] decode]
                     [(keyword k) v])))]
        (prn :now-m? mp (map? mp))))

#_(let [db (.instance ls/Localstore)]
    (dp :bam-db!!!!!!!!!!! db)

    ;
    ; 3n3aym16h
    ; 5ggmwupfb
    ;
    (let [coll (.collection db "todos")
          ;id (.id (.doc (.collection db "todos")))
          ;;id #_ "5ggmwupfb"  (.id (.doc coll))
          ]
      (dp :BAM-coll coll)
      (dp :BAM-doc-get-all (await (.get coll)))
      #_(dp :BAM-doc-get-all-decode (convert/jsonDecode
                                      (await (.get coll))))
      ;;(dp :BAM-doc-id id)

      ;;; --- write new entry -----------------------------
      (let [coll (.collection db "todos")
            new-id (.id (.doc coll))]
        ;;id #_ "5ggmwupfb"  (.id (.doc coll))
        (-> db
          (.collection "todos")
          (.doc new-id)
          (.set {"title" "Todo title Two"})))

      ;;; --- read known IDs ------------------------------
      (doseq [id ["5ggmwupfb" "3n3aym16h"]]
        (let [rb (await (-> db
                          (.collection "todos")
                          (.doc id)
                          .get))]
          (dp :readback!!!!!! id :data (string? rb) (map? rb) :raw> rb)
          (dp :readback!!!!!! id :keys!!! (keys rb) rb)
          (dp :CLJD-map!!!! (walk/keywordize-keys
                              (into {}
                                (for [k (keys rb)]
                                  [k (get rb k)]))))
          #_(dp :readback!!!!!! id :decode!! (convert/jsonDecode rb) rb)))

      ;;  Unhandled Exception: type '_InternalLinkedHashMap<String, dynamic>' is not a subtype of type 'String' in type cast

      #_(let [rb (await (-> db
                          (.collection "todos")
                          (.doc id)
                          .get))]
          (dp :readback!!!!!!!!! id :data rb))))

;(let [{:keys [initial-open? distance actions] :or [initial-open? false]}
;      {:distance 42}]
;  (dp :s distance :io initial-open?))

(defn test-new-todo-list []
  (dp :BAM-new-todo)
  (let [tl (todo/make-todo-list "boom")]
    (dp :back)
    (dp :bingo-td-list @tl)
    (md/mswap! tl :kids conj (todo/make-todo tl "wash dog" false))
    (dp :pushed!!!!!!)
    (dp :tl+1 @tl)
    (dp :k1 @(first (mget tl :kids)))
    (store/read-all-docs "boom")))



(defn hack-one [collection-name id]
  (.ensureInitialized w/WidgetsFlutterBinding)
  ;;; --- read all docs ---------------------------
  (let [db (.-instance ls/Localstore)
        rb (await (-> db
                    (.collection collection-name)
                    (.doc id)
                    .get))]
    (cond
      (nil? rb)
      (do
        (dp :doc-id id :not-found-in collection-name)
        (dp :all-follow)
        (store/read-all-docs "todos"))

      :else (do
              (dp :raw-rb rb)
              (dp :CLJD-map!!!! (store/dart-map->cljd-map rb))
              (do
                (dp :deleteing!!!!!!! id)
                (let [del-res (await (-> db
                                  (.collection collection-name)
                                  (.doc id)
                                  .delete))]
                  (dp :delete-returned del-res)
                  (let [doc (await (-> db
                                     (.collection collection-name)
                                     (.doc id)
                                     .get))]
                    (dp :read-of-deleted-sees doc))))))
    ))

(defn read-one [collection-name id]
  (.ensureInitialized w/WidgetsFlutterBinding)
  ;;; --- read all docs ---------------------------
  (let [db (.-instance ls/Localstore)
        rb (await (-> db
                    (.collection collection-name)
                    (.doc id)
                    .get))]
    (if rb
      (dp :read id :got (store/dart-map->cljd-map rb))
      (dp :read id :notfound))))

(defn test []
  ;;(read-one "todos" "3kpfwt4pp")
  ;(hack-one "todos" "3kpfwt4pp")
  ;;(store/delete-all-docs "boom")
  ;(store/read-all-docs "boom")
  ;(reset! todo/todo-sid 0)
  (test-new-todo-list)
  )



#_(doseq [db-id (keys docs)]
    (dp :deleting db-id (string? db-id))
    (let [dres (await (-> db
                        (.collection coll-name)
                        (.doc db-id)
                        .delete))]
      (dp :dlete-says dres)))

#_(let [tds (for [k (keys docs)]
              (let [td (get docs k)]
                (walk/keywordize-keys
                  (into {}
                    (for [k (keys td)]
                      [k (get td k)])))))]
    (dp :todos!!!! tds)
    (doseq [td tds]
      (dp :deleting (:ls-id td))
      (let [dres (await (-> db
                          (.collection "todos")
                          (.doc (:ls-id td))
                          .delete))]
        (dp :dlete-says dres)))
    #_(doseq [td tds]
        (dp :deleting (:ls-id td))
        (let [dres (await (-> db
                            (.collection "todos")
                            (.doc (:ls-id td))
                            .delete))]
          (dp :dlete-says dres))))

