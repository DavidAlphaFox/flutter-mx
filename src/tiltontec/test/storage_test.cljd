(ns tiltontec.test.storage-test
  (:require
    ["dart:developer" :as dev]
    ["dart:math" :as mth]
    ["dart:convert" :as convert]
    [tiltontec.util.base :refer [dprn dp dpx]]
    [tiltontec.model.core :refer [mget mswap!] :as md]
    ;;[tiltontec.mx-flutter.core :as fx]
    ["package:localstore/localstore.dart" :as ls]
    ["package:flutter/widgets.dart" :as w]
    [tiltontec.mx-flutter.store :as store]

    [tiltontec.demo.todoMVC.todo :as todo]
    [clojure.walk :as walk]
    )

  )



(defn just-hack []
  (.ensureInitialized w/WidgetsFlutterBinding)
  ;;; --- read all docs ---------------------------
  (let [id "1isb6j40s"
        db (.-instance ls/Localstore)
        rb (await (-> db
                    (.collection "todos")
                    (.doc id)
                    .get))]
    (dp :readback!!!!!! id :data (string? rb) (map? rb) :raw> rb)
    (dp :readback!!!!!! id :keys!!! (keys rb) rb)
    (dp :CLJD-map!!!! (walk/keywordize-keys
                        (into {}
                          (for [k (keys rb)]
                            [k (get rb k)]))))
    (dp :deleteing!!!!!!!)
    (let [db (await (-> db
                      (.collection "todos")
                      (.doc id)
                      .delete))]
      (dp :dlete-says db))
    ))

(defn read-all-docs [coll-name]
  (.ensureInitialized w/WidgetsFlutterBinding)
  ;;; --- read all docs ---------------------------
  (let [db (.-instance ls/Localstore)
        coll (.collection db coll-name)
        docs (into {} (await (.get coll)))]
    (dp :coll-todos  coll)
    (dp :docs  docs)
    docs))

(defn test-store-one-map []
  (.ensureInitialized w/WidgetsFlutterBinding)
  (let [db (.-instance ls/Localstore)]
    ;;; --- write new entry -----------------------------
    (let [coll (.collection db "todos")
          new-id (.-id (.doc coll))]
      (dp :creating-new-to!! new-id)
      (-> db
        (.collection "todos")
        (.doc new-id)
        (.set (walk/stringify-keys
                {:title     "Todo title Two"
                 :weight    174.3
                 :completed false})))

      ;;; --- read known IDs ------------------------------
      (doseq [id [new-id] #_["5ggmwupfb" "3n3aym16h"]]
        (let [rb (await (-> db
                          (.collection "todos")
                          (.doc id)
                          .get))]
          (dp :readback!!!!!! id :data (string? rb) (map? rb) :raw> rb)
          (dp :readback!!!!!! id :keys!!! (keys rb) rb)
          (dp :CLJD-map!!!! (walk/keywordize-keys
                              (into {}
                                (for [k (keys rb)]
                                  [k (get rb k)])))))))))

(defn load-test-todos []
  (dp :loading!!!!!!!!-todos-not)

  (.ensureInitialized w/WidgetsFlutterBinding)
  (dp :initialized!!!!!-todos)

  ;(.ensureInitialized w/WidgetsFlutterBinding)

  #_(let [test-todos [{:title     "Wash car"
                       :completed false}
                      {:title     "Wash dog"
                       :completed true}
                      {:title     "Walk dog"
                       :completed false}]
          db (.-instance ls/Localstore)
          coll (.collection db "todo")]
      (doseq [{:keys [title completed]} test-todos]
        (md/make-ls
          :mx-type (ToDo)
          :title title
          :completed completed))
      )

  ;;; --- read known IDs ------------------------------
  (let [db (.-instance ls/Localstore)]
    (doseq [id ["5ggmwupfb" "3n3aym16h"]]
      (let [rb (await (-> db
                        (.collection "todos")
                        (.doc id)
                        .get))]
        (dp :readback!!!!!! id :data (string? rb) (map? rb) :raw> rb)
        (dp :readback!!!!!! id :keys!!! (keys rb) rb)
        (dp :CLJD-map!!!! (walk/keywordize-keys
                            (into {}
                              (for [k (keys rb)]
                                [k (get rb k)]))))
        #_(dp :readback!!!!!! id :decode!! (convert/jsonDecode rb) rb)))

    (doseq [id ["5ggmwupfb" "3n3aym16h"]]
      (let [rb (walk/keywordize-keys
                 (into {}
                   (await (-> db
                            (.collection "todos")
                            (.doc id)
                            .get))))]
        (dp :re22222!!!!!! id :data (string? rb) (map? rb) :raw> rb)
        (dp :re22222k!!!!!! id :keys!!! (keys rb) rb)
        (dp :CLJD-map!!!! rb)
        #_(dp :readback!!!!!! id :decode!! (convert/jsonDecode rb) rb))))

  ; (def items
  ;  (-> (await db)
  ;      (.collection "todos")
  ;      .get))

  #_(let [rb (await (-> db
                      (.collection "todos")
                      (.doc id)
                      .get))]
      (dp :readback!!!!!!!!! id :data rb)))


(comment

  ;(dp :jsowrite!!!!! (json/write-str {:a 1 :b 2}))
  ;(dp :jsoencode (convert/jsonEncode {:a 1 :b 2}))


  (let [db (.-instance ls/Localstore)]
    (dp :bam-db!!!!!!!!!!! db)

    ;
    ; 3n3aym16h
    ; 5ggmwupfb
    ;
    (let [coll (.collection db "todos")
          ;id (.id (.doc (.collection db "todos")))
          ;;id #_ "5ggmwupfb"  (.id (.doc coll))
          ]
      (dp :BAM-coll coll)
      (dp :BAM-doc-get-all (await (.get coll)))
      #_(dp :BAM-doc-get-all-decode (convert/jsonDecode
                                      (await (.get coll))))
      ;;(dp :BAM-doc-id id)

      ;;; --- write new entry -----------------------------
      (let [coll (.collection db "todos")
            new-id (.id (.doc coll))]
        ;;id #_ "5ggmwupfb"  (.id (.doc coll))
        (-> db
          (.collection "todos")
          (.doc new-id)
          (.set {"title" "Todo title Two"})))

      ;;; --- read known IDs ------------------------------
      (doseq [id ["5ggmwupfb" "3n3aym16h"]]
        (let [rb (await (-> db
                          (.collection "todos")
                          (.doc id)
                          .get))]
          (dp :readback!!!!!! id :data (string? rb) (map? rb) :raw> rb)
          (dp :readback!!!!!! id :keys!!! (keys rb) rb)
          (dp :CLJD-map!!!! (walk/keywordize-keys
                              (into {}
                                (for [k (keys rb)]
                                  [k (get rb k)]))))
          #_(dp :readback!!!!!! id :decode!! (convert/jsonDecode rb) rb)))

      ;;  Unhandled Exception: type '_InternalLinkedHashMap<String, dynamic>' is not a subtype of type 'String' in type cast

      #_(let [rb (await (-> db
                          (.collection "todos")
                          (.doc id)
                          .get))]
          (dp :readback!!!!!!!!! id :data rb)))))

(defn mess-with-json []
  #_(let [decode (convert/jsonDecode "{ \"name\": \"Pizza da Mario\", \"cuisine\": \"Italian\" }")]
      (dp :decodes? (string? decode))
      (dp :decodes-map? (map? decode))
      (dp :decodes-keywordized (walk/keywordize-keys decode))
      (dp :decode-k (keys decode))
      (dp :cuisi (get decode "cuisine"))
      (dp :decode decode)

      (doseq [[k v] decode]
        (dp :doseq k v)
        (dp :doseq (keyword k) v)
        )

      (dp :forrrrr (into {}
                     (for [[k v] decode]
                       [(keyword k) v])))
      #_(let [mp (into {}
                   (apply concat
                     (for [[k v] decode]
                       [(keyword k) v])))]
          (prn :now-m? mp (map? mp)))))

;(dp :jsowrite!!!!! (json/write-str {:a 1 :b 2}))
;(dp :jsoencode (convert/jsonEncode {:a 1 :b 2}))
#_(let [decode (convert/jsonDecode "{ \"name\": \"Pizza da Mario\", \"cuisine\": \"Italian\" }")]
    (dp :decodes? (string? decode))
    (dp :decodes-map? (map? decode))
    (dp :decodes-keywordized (walk/keywordize-keys decode))
    (dp :decode-k (keys decode))
    (dp :cuisi (get decode "cuisine"))
    (dp :decode decode)

    (doseq [[k v] decode]
      (dp :doseq k v)
      (dp :doseq (keyword k) v)
      )

    (dp :forrrrr (into {}
                   (for [[k v] decode]
                     [(keyword k) v])))
    #_(let [mp (into {}
                 (apply concat
                   (for [[k v] decode]
                     [(keyword k) v])))]
        (prn :now-m? mp (map? mp))))

#_(let [db (.instance ls/Localstore)]
    (dp :bam-db!!!!!!!!!!! db)

    ;
    ; 3n3aym16h
    ; 5ggmwupfb
    ;
    (let [coll (.collection db "todos")
          ;id (.id (.doc (.collection db "todos")))
          ;;id #_ "5ggmwupfb"  (.id (.doc coll))
          ]
      (dp :BAM-coll coll)
      (dp :BAM-doc-get-all (await (.get coll)))
      #_(dp :BAM-doc-get-all-decode (convert/jsonDecode
                                      (await (.get coll))))
      ;;(dp :BAM-doc-id id)

      ;;; --- write new entry -----------------------------
      (let [coll (.collection db "todos")
            new-id (.id (.doc coll))]
        ;;id #_ "5ggmwupfb"  (.id (.doc coll))
        (-> db
          (.collection "todos")
          (.doc new-id)
          (.set {"title" "Todo title Two"})))

      ;;; --- read known IDs ------------------------------
      (doseq [id ["5ggmwupfb" "3n3aym16h"]]
        (let [rb (await (-> db
                          (.collection "todos")
                          (.doc id)
                          .get))]
          (dp :readback!!!!!! id :data (string? rb) (map? rb) :raw> rb)
          (dp :readback!!!!!! id :keys!!! (keys rb) rb)
          (dp :CLJD-map!!!! (walk/keywordize-keys
                              (into {}
                                (for [k (keys rb)]
                                  [k (get rb k)]))))
          #_(dp :readback!!!!!! id :decode!! (convert/jsonDecode rb) rb)))

      ;;  Unhandled Exception: type '_InternalLinkedHashMap<String, dynamic>' is not a subtype of type 'String' in type cast

      #_(let [rb (await (-> db
                          (.collection "todos")
                          (.doc id)
                          .get))]
          (dp :readback!!!!!!!!! id :data rb))))

;(let [{:keys [initial-open? distance actions] :or [initial-open? false]}
;      {:distance 42}]
;  (dp :s distance :io initial-open?))

(defn test-new-todo-list []
  (dp :BAM-new-todo)
  (let [tl (todo/make-todo-list "boom")]
    (dp :back)
    (dp :bingo-td-list @tl)
    (md/mswap! tl :kids  conj (todo/make-todo "wash dog" false))
    (dp :pushed!!!!!!)
    (dp :tl+1 @tl)
    (dp :k1 @(first (mget tl :kids)))))

(defn test []
  ;;(read-all-docs "todos")
  (reset! todo/todo-sid 0)
  (test-new-todo-list))